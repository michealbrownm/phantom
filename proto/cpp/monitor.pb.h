// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: monitor.proto

#ifndef PROTOBUF_monitor_2eproto__INCLUDED
#define PROTOBUF_monitor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "chain.pb.h"
// @@protoc_insertion_point(includes)

namespace monitor {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_monitor_2eproto();
void protobuf_AssignDesc_monitor_2eproto();
void protobuf_ShutdownFile_monitor_2eproto();

class AlertStatus;
class PhantomStatus;
class CPU;
class GlueManager;
class Hello;
class LedgerStatus;
class Partition;
class Peer;
class PeerManager;
class Register;
class SystemProperty;
class SystemResource;
class SystemStatus;

enum MONITOR_MESSAGE_TYPE {
  MONITOR_MSGTYPE_NONE = 0,
  MONITOR_MSGTYPE_HELLO = 30,
  MONITOR_MSGTYPE_REGISTER = 31,
  MONITOR_MSGTYPE_PHANTOM = 32,
  MONITOR_MSGTYPE_LEDGER = 33,
  MONITOR_MSGTYPE_SYSTEM = 34,
  MONITOR_MSGTYPE_ALERT = 35,
  MONITOR_MSGTYPE_NOTICE = 36,
  MONITOR_MSGTYPE_ACCOUNT_EXCEPTION = 37,
  MONITOR_MSGTYPE_ERROR = 39,
  MONITOR_MESSAGE_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MONITOR_MESSAGE_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MONITOR_MESSAGE_TYPE_IsValid(int value);
const MONITOR_MESSAGE_TYPE MONITOR_MESSAGE_TYPE_MIN = MONITOR_MSGTYPE_NONE;
const MONITOR_MESSAGE_TYPE MONITOR_MESSAGE_TYPE_MAX = MONITOR_MSGTYPE_ERROR;
const int MONITOR_MESSAGE_TYPE_ARRAYSIZE = MONITOR_MESSAGE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MONITOR_MESSAGE_TYPE_descriptor();
inline const ::std::string& MONITOR_MESSAGE_TYPE_Name(MONITOR_MESSAGE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MONITOR_MESSAGE_TYPE_descriptor(), value);
}
inline bool MONITOR_MESSAGE_TYPE_Parse(
    const ::std::string& name, MONITOR_MESSAGE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MONITOR_MESSAGE_TYPE>(
    MONITOR_MESSAGE_TYPE_descriptor(), name, value);
}
// ===================================================================

class Hello : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.Hello) */ {
 public:
  Hello();
  virtual ~Hello();

  Hello(const Hello& from);

  inline Hello& operator=(const Hello& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hello& default_instance();

  void Swap(Hello* other);

  // implements Message ----------------------------------------------

  inline Hello* New() const { return New(NULL); }

  Hello* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hello& from);
  void MergeFrom(const Hello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Hello* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 service_version = 1;
  void clear_service_version();
  static const int kServiceVersionFieldNumber = 1;
  ::google::protobuf::int64 service_version() const;
  void set_service_version(::google::protobuf::int64 value);

  // optional int64 connection_timeout = 2;
  void clear_connection_timeout();
  static const int kConnectionTimeoutFieldNumber = 2;
  ::google::protobuf::int64 connection_timeout() const;
  void set_connection_timeout(::google::protobuf::int64 value);

  // optional int64 timestamp = 3;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:monitor.Hello)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 service_version_;
  ::google::protobuf::int64 connection_timeout_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static Hello* default_instance_;
};
// -------------------------------------------------------------------

class Register : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.Register) */ {
 public:
  Register();
  virtual ~Register();

  Register(const Register& from);

  inline Register& operator=(const Register& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Register& default_instance();

  void Swap(Register* other);

  // implements Message ----------------------------------------------

  inline Register* New() const { return New(NULL); }

  Register* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Register& from);
  void MergeFrom(const Register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Register* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string blockchain_version = 2;
  void clear_blockchain_version();
  static const int kBlockchainVersionFieldNumber = 2;
  const ::std::string& blockchain_version() const;
  void set_blockchain_version(const ::std::string& value);
  void set_blockchain_version(const char* value);
  void set_blockchain_version(const char* value, size_t size);
  ::std::string* mutable_blockchain_version();
  ::std::string* release_blockchain_version();
  void set_allocated_blockchain_version(::std::string* blockchain_version);

  // optional int64 data_version = 3;
  void clear_data_version();
  static const int kDataVersionFieldNumber = 3;
  ::google::protobuf::int64 data_version() const;
  void set_data_version(::google::protobuf::int64 value);

  // optional int64 timestamp = 4;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:monitor.Register)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr blockchain_version_;
  ::google::protobuf::int64 data_version_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static Register* default_instance_;
};
// -------------------------------------------------------------------

class Peer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.Peer) */ {
 public:
  Peer();
  virtual ~Peer();

  Peer(const Peer& from);

  inline Peer& operator=(const Peer& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Peer& default_instance();

  void Swap(Peer* other);

  // implements Message ----------------------------------------------

  inline Peer* New() const { return New(NULL); }

  Peer* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Peer& from);
  void MergeFrom(const Peer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Peer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional int64 delay = 2;
  void clear_delay();
  static const int kDelayFieldNumber = 2;
  ::google::protobuf::int64 delay() const;
  void set_delay(::google::protobuf::int64 value);

  // optional bool active = 3;
  void clear_active();
  static const int kActiveFieldNumber = 3;
  bool active() const;
  void set_active(bool value);

  // optional string ip_address = 4;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 4;
  const ::std::string& ip_address() const;
  void set_ip_address(const ::std::string& value);
  void set_ip_address(const char* value);
  void set_ip_address(const char* value, size_t size);
  ::std::string* mutable_ip_address();
  ::std::string* release_ip_address();
  void set_allocated_ip_address(::std::string* ip_address);

  // @@protoc_insertion_point(class_scope:monitor.Peer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::int64 delay_;
  ::google::protobuf::internal::ArenaStringPtr ip_address_;
  bool active_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static Peer* default_instance_;
};
// -------------------------------------------------------------------

class GlueManager : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.GlueManager) */ {
 public:
  GlueManager();
  virtual ~GlueManager();

  GlueManager(const GlueManager& from);

  inline GlueManager& operator=(const GlueManager& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GlueManager& default_instance();

  void Swap(GlueManager* other);

  // implements Message ----------------------------------------------

  inline GlueManager* New() const { return New(NULL); }

  GlueManager* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GlueManager& from);
  void MergeFrom(const GlueManager& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GlueManager* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string system_current_time = 1;
  void clear_system_current_time();
  static const int kSystemCurrentTimeFieldNumber = 1;
  const ::std::string& system_current_time() const;
  void set_system_current_time(const ::std::string& value);
  void set_system_current_time(const char* value);
  void set_system_current_time(const char* value, size_t size);
  ::std::string* mutable_system_current_time();
  ::std::string* release_system_current_time();
  void set_allocated_system_current_time(::std::string* system_current_time);

  // optional string process_uptime = 2;
  void clear_process_uptime();
  static const int kProcessUptimeFieldNumber = 2;
  const ::std::string& process_uptime() const;
  void set_process_uptime(const ::std::string& value);
  void set_process_uptime(const char* value);
  void set_process_uptime(const char* value, size_t size);
  ::std::string* mutable_process_uptime();
  ::std::string* release_process_uptime();
  void set_allocated_process_uptime(::std::string* process_uptime);

  // optional string system_uptime = 3;
  void clear_system_uptime();
  static const int kSystemUptimeFieldNumber = 3;
  const ::std::string& system_uptime() const;
  void set_system_uptime(const ::std::string& value);
  void set_system_uptime(const char* value);
  void set_system_uptime(const char* value, size_t size);
  ::std::string* mutable_system_uptime();
  ::std::string* release_system_uptime();
  void set_allocated_system_uptime(::std::string* system_uptime);

  // @@protoc_insertion_point(class_scope:monitor.GlueManager)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr system_current_time_;
  ::google::protobuf::internal::ArenaStringPtr process_uptime_;
  ::google::protobuf::internal::ArenaStringPtr system_uptime_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static GlueManager* default_instance_;
};
// -------------------------------------------------------------------

class PeerManager : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.PeerManager) */ {
 public:
  PeerManager();
  virtual ~PeerManager();

  PeerManager(const PeerManager& from);

  inline PeerManager& operator=(const PeerManager& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerManager& default_instance();

  void Swap(PeerManager* other);

  // implements Message ----------------------------------------------

  inline PeerManager* New() const { return New(NULL); }

  PeerManager* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PeerManager& from);
  void MergeFrom(const PeerManager& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PeerManager* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string peer_id = 1;
  void clear_peer_id();
  static const int kPeerIdFieldNumber = 1;
  const ::std::string& peer_id() const;
  void set_peer_id(const ::std::string& value);
  void set_peer_id(const char* value);
  void set_peer_id(const char* value, size_t size);
  ::std::string* mutable_peer_id();
  ::std::string* release_peer_id();
  void set_allocated_peer_id(::std::string* peer_id);

  // repeated .monitor.Peer peer = 2;
  int peer_size() const;
  void clear_peer();
  static const int kPeerFieldNumber = 2;
  const ::monitor::Peer& peer(int index) const;
  ::monitor::Peer* mutable_peer(int index);
  ::monitor::Peer* add_peer();
  ::google::protobuf::RepeatedPtrField< ::monitor::Peer >*
      mutable_peer();
  const ::google::protobuf::RepeatedPtrField< ::monitor::Peer >&
      peer() const;

  // @@protoc_insertion_point(class_scope:monitor.PeerManager)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr peer_id_;
  ::google::protobuf::RepeatedPtrField< ::monitor::Peer > peer_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static PeerManager* default_instance_;
};
// -------------------------------------------------------------------

class PhantomStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.PhantomStatus) */ {
 public:
  PhantomStatus();
  virtual ~PhantomStatus();

  PhantomStatus(const PhantomStatus& from);

  inline PhantomStatus& operator=(const PhantomStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PhantomStatus& default_instance();

  void Swap(PhantomStatus* other);

  // implements Message ----------------------------------------------

  inline PhantomStatus* New() const { return New(NULL); }

  PhantomStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PhantomStatus& from);
  void MergeFrom(const PhantomStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PhantomStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .monitor.GlueManager glue_manager = 1;
  bool has_glue_manager() const;
  void clear_glue_manager();
  static const int kGlueManagerFieldNumber = 1;
  const ::monitor::GlueManager& glue_manager() const;
  ::monitor::GlueManager* mutable_glue_manager();
  ::monitor::GlueManager* release_glue_manager();
  void set_allocated_glue_manager(::monitor::GlueManager* glue_manager);

  // optional .monitor.PeerManager peer_manager = 2;
  bool has_peer_manager() const;
  void clear_peer_manager();
  static const int kPeerManagerFieldNumber = 2;
  const ::monitor::PeerManager& peer_manager() const;
  ::monitor::PeerManager* mutable_peer_manager();
  ::monitor::PeerManager* release_peer_manager();
  void set_allocated_peer_manager(::monitor::PeerManager* peer_manager);

  // @@protoc_insertion_point(class_scope:monitor.PhantomStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::monitor::GlueManager* glue_manager_;
  ::monitor::PeerManager* peer_manager_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static PhantomStatus* default_instance_;
};
// -------------------------------------------------------------------

class LedgerStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.LedgerStatus) */ {
 public:
  LedgerStatus();
  virtual ~LedgerStatus();

  LedgerStatus(const LedgerStatus& from);

  inline LedgerStatus& operator=(const LedgerStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LedgerStatus& default_instance();

  void Swap(LedgerStatus* other);

  // implements Message ----------------------------------------------

  inline LedgerStatus* New() const { return New(NULL); }

  LedgerStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LedgerStatus& from);
  void MergeFrom(const LedgerStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LedgerStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.LedgerHeader ledger_header = 1;
  bool has_ledger_header() const;
  void clear_ledger_header();
  static const int kLedgerHeaderFieldNumber = 1;
  const ::protocol::LedgerHeader& ledger_header() const;
  ::protocol::LedgerHeader* mutable_ledger_header();
  ::protocol::LedgerHeader* release_ledger_header();
  void set_allocated_ledger_header(::protocol::LedgerHeader* ledger_header);

  // optional int64 transaction_size = 2;
  void clear_transaction_size();
  static const int kTransactionSizeFieldNumber = 2;
  ::google::protobuf::int64 transaction_size() const;
  void set_transaction_size(::google::protobuf::int64 value);

  // optional int64 account_count = 3;
  void clear_account_count();
  static const int kAccountCountFieldNumber = 3;
  ::google::protobuf::int64 account_count() const;
  void set_account_count(::google::protobuf::int64 value);

  // optional int64 timestamp = 4;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:monitor.LedgerStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::protocol::LedgerHeader* ledger_header_;
  ::google::protobuf::int64 transaction_size_;
  ::google::protobuf::int64 account_count_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static LedgerStatus* default_instance_;
};
// -------------------------------------------------------------------

class SystemProperty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.SystemProperty) */ {
 public:
  SystemProperty();
  virtual ~SystemProperty();

  SystemProperty(const SystemProperty& from);

  inline SystemProperty& operator=(const SystemProperty& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemProperty& default_instance();

  void Swap(SystemProperty* other);

  // implements Message ----------------------------------------------

  inline SystemProperty* New() const { return New(NULL); }

  SystemProperty* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemProperty& from);
  void MergeFrom(const SystemProperty& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemProperty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string host_name = 1;
  void clear_host_name();
  static const int kHostNameFieldNumber = 1;
  const ::std::string& host_name() const;
  void set_host_name(const ::std::string& value);
  void set_host_name(const char* value);
  void set_host_name(const char* value, size_t size);
  ::std::string* mutable_host_name();
  ::std::string* release_host_name();
  void set_allocated_host_name(::std::string* host_name);

  // optional string os_version = 2;
  void clear_os_version();
  static const int kOsVersionFieldNumber = 2;
  const ::std::string& os_version() const;
  void set_os_version(const ::std::string& value);
  void set_os_version(const char* value);
  void set_os_version(const char* value, size_t size);
  ::std::string* mutable_os_version();
  ::std::string* release_os_version();
  void set_allocated_os_version(::std::string* os_version);

  // optional int64 startup_time = 3;
  void clear_startup_time();
  static const int kStartupTimeFieldNumber = 3;
  ::google::protobuf::int64 startup_time() const;
  void set_startup_time(::google::protobuf::int64 value);

  // optional string os_bit = 4;
  void clear_os_bit();
  static const int kOsBitFieldNumber = 4;
  const ::std::string& os_bit() const;
  void set_os_bit(const ::std::string& value);
  void set_os_bit(const char* value);
  void set_os_bit(const char* value, size_t size);
  ::std::string* mutable_os_bit();
  ::std::string* release_os_bit();
  void set_allocated_os_bit(::std::string* os_bit);

  // @@protoc_insertion_point(class_scope:monitor.SystemProperty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr host_name_;
  ::google::protobuf::internal::ArenaStringPtr os_version_;
  ::google::protobuf::int64 startup_time_;
  ::google::protobuf::internal::ArenaStringPtr os_bit_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static SystemProperty* default_instance_;
};
// -------------------------------------------------------------------

class SystemResource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.SystemResource) */ {
 public:
  SystemResource();
  virtual ~SystemResource();

  SystemResource(const SystemResource& from);

  inline SystemResource& operator=(const SystemResource& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemResource& default_instance();

  void Swap(SystemResource* other);

  // implements Message ----------------------------------------------

  inline SystemResource* New() const { return New(NULL); }

  SystemResource* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemResource& from);
  void MergeFrom(const SystemResource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemResource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 available = 1;
  void clear_available();
  static const int kAvailableFieldNumber = 1;
  ::google::protobuf::int64 available() const;
  void set_available(::google::protobuf::int64 value);

  // optional int64 total = 2;
  void clear_total();
  static const int kTotalFieldNumber = 2;
  ::google::protobuf::int64 total() const;
  void set_total(::google::protobuf::int64 value);

  // optional double used_percent = 3;
  void clear_used_percent();
  static const int kUsedPercentFieldNumber = 3;
  double used_percent() const;
  void set_used_percent(double value);

  // optional string description = 4;
  void clear_description();
  static const int kDescriptionFieldNumber = 4;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:monitor.SystemResource)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 available_;
  ::google::protobuf::int64 total_;
  double used_percent_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static SystemResource* default_instance_;
};
// -------------------------------------------------------------------

class Partition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.Partition) */ {
 public:
  Partition();
  virtual ~Partition();

  Partition(const Partition& from);

  inline Partition& operator=(const Partition& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Partition& default_instance();

  void Swap(Partition* other);

  // implements Message ----------------------------------------------

  inline Partition* New() const { return New(NULL); }

  Partition* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Partition& from);
  void MergeFrom(const Partition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Partition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 total_bytes = 1;
  void clear_total_bytes();
  static const int kTotalBytesFieldNumber = 1;
  ::google::protobuf::int64 total_bytes() const;
  void set_total_bytes(::google::protobuf::int64 value);

  // repeated .monitor.SystemResource partition = 2;
  int partition_size() const;
  void clear_partition();
  static const int kPartitionFieldNumber = 2;
  const ::monitor::SystemResource& partition(int index) const;
  ::monitor::SystemResource* mutable_partition(int index);
  ::monitor::SystemResource* add_partition();
  ::google::protobuf::RepeatedPtrField< ::monitor::SystemResource >*
      mutable_partition();
  const ::google::protobuf::RepeatedPtrField< ::monitor::SystemResource >&
      partition() const;

  // @@protoc_insertion_point(class_scope:monitor.Partition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 total_bytes_;
  ::google::protobuf::RepeatedPtrField< ::monitor::SystemResource > partition_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static Partition* default_instance_;
};
// -------------------------------------------------------------------

class CPU : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.CPU) */ {
 public:
  CPU();
  virtual ~CPU();

  CPU(const CPU& from);

  inline CPU& operator=(const CPU& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPU& default_instance();

  void Swap(CPU* other);

  // implements Message ----------------------------------------------

  inline CPU* New() const { return New(NULL); }

  CPU* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPU& from);
  void MergeFrom(const CPU& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CPU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double used_percent = 1;
  void clear_used_percent();
  static const int kUsedPercentFieldNumber = 1;
  double used_percent() const;
  void set_used_percent(double value);

  // @@protoc_insertion_point(class_scope:monitor.CPU)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double used_percent_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static CPU* default_instance_;
};
// -------------------------------------------------------------------

class SystemStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.SystemStatus) */ {
 public:
  SystemStatus();
  virtual ~SystemStatus();

  SystemStatus(const SystemStatus& from);

  inline SystemStatus& operator=(const SystemStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemStatus& default_instance();

  void Swap(SystemStatus* other);

  // implements Message ----------------------------------------------

  inline SystemStatus* New() const { return New(NULL); }

  SystemStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemStatus& from);
  void MergeFrom(const SystemStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .monitor.SystemProperty property = 1;
  bool has_property() const;
  void clear_property();
  static const int kPropertyFieldNumber = 1;
  const ::monitor::SystemProperty& property() const;
  ::monitor::SystemProperty* mutable_property();
  ::monitor::SystemProperty* release_property();
  void set_allocated_property(::monitor::SystemProperty* property);

  // optional .monitor.SystemResource memory = 2;
  bool has_memory() const;
  void clear_memory();
  static const int kMemoryFieldNumber = 2;
  const ::monitor::SystemResource& memory() const;
  ::monitor::SystemResource* mutable_memory();
  ::monitor::SystemResource* release_memory();
  void set_allocated_memory(::monitor::SystemResource* memory);

  // optional .monitor.CPU cpu = 3;
  bool has_cpu() const;
  void clear_cpu();
  static const int kCpuFieldNumber = 3;
  const ::monitor::CPU& cpu() const;
  ::monitor::CPU* mutable_cpu();
  ::monitor::CPU* release_cpu();
  void set_allocated_cpu(::monitor::CPU* cpu);

  // optional .monitor.Partition partitions = 4;
  bool has_partitions() const;
  void clear_partitions();
  static const int kPartitionsFieldNumber = 4;
  const ::monitor::Partition& partitions() const;
  ::monitor::Partition* mutable_partitions();
  ::monitor::Partition* release_partitions();
  void set_allocated_partitions(::monitor::Partition* partitions);

  // @@protoc_insertion_point(class_scope:monitor.SystemStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::monitor::SystemProperty* property_;
  ::monitor::SystemResource* memory_;
  ::monitor::CPU* cpu_;
  ::monitor::Partition* partitions_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static SystemStatus* default_instance_;
};
// -------------------------------------------------------------------

class AlertStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:monitor.AlertStatus) */ {
 public:
  AlertStatus();
  virtual ~AlertStatus();

  AlertStatus(const AlertStatus& from);

  inline AlertStatus& operator=(const AlertStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlertStatus& default_instance();

  void Swap(AlertStatus* other);

  // implements Message ----------------------------------------------

  inline AlertStatus* New() const { return New(NULL); }

  AlertStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlertStatus& from);
  void MergeFrom(const AlertStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AlertStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 ledger_sequence = 1;
  void clear_ledger_sequence();
  static const int kLedgerSequenceFieldNumber = 1;
  ::google::protobuf::int64 ledger_sequence() const;
  void set_ledger_sequence(::google::protobuf::int64 value);

  // optional string node_id = 2;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  const ::std::string& node_id() const;
  void set_node_id(const ::std::string& value);
  void set_node_id(const char* value);
  void set_node_id(const char* value, size_t size);
  ::std::string* mutable_node_id();
  ::std::string* release_node_id();
  void set_allocated_node_id(::std::string* node_id);

  // optional .monitor.SystemStatus system = 3;
  bool has_system() const;
  void clear_system();
  static const int kSystemFieldNumber = 3;
  const ::monitor::SystemStatus& system() const;
  ::monitor::SystemStatus* mutable_system();
  ::monitor::SystemStatus* release_system();
  void set_allocated_system(::monitor::SystemStatus* system);

  // @@protoc_insertion_point(class_scope:monitor.AlertStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 ledger_sequence_;
  ::google::protobuf::internal::ArenaStringPtr node_id_;
  ::monitor::SystemStatus* system_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_monitor_2eproto();
  friend void protobuf_AssignDesc_monitor_2eproto();
  friend void protobuf_ShutdownFile_monitor_2eproto();

  void InitAsDefaultInstance();
  static AlertStatus* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Hello

// optional int64 service_version = 1;
inline void Hello::clear_service_version() {
  service_version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Hello::service_version() const {
  // @@protoc_insertion_point(field_get:monitor.Hello.service_version)
  return service_version_;
}
inline void Hello::set_service_version(::google::protobuf::int64 value) {
  
  service_version_ = value;
  // @@protoc_insertion_point(field_set:monitor.Hello.service_version)
}

// optional int64 connection_timeout = 2;
inline void Hello::clear_connection_timeout() {
  connection_timeout_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Hello::connection_timeout() const {
  // @@protoc_insertion_point(field_get:monitor.Hello.connection_timeout)
  return connection_timeout_;
}
inline void Hello::set_connection_timeout(::google::protobuf::int64 value) {
  
  connection_timeout_ = value;
  // @@protoc_insertion_point(field_set:monitor.Hello.connection_timeout)
}

// optional int64 timestamp = 3;
inline void Hello::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Hello::timestamp() const {
  // @@protoc_insertion_point(field_get:monitor.Hello.timestamp)
  return timestamp_;
}
inline void Hello::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:monitor.Hello.timestamp)
}

// -------------------------------------------------------------------

// Register

// optional string id = 1;
inline void Register::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Register::id() const {
  // @@protoc_insertion_point(field_get:monitor.Register.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.Register.id)
}
inline void Register::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.Register.id)
}
inline void Register::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.Register.id)
}
inline ::std::string* Register::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:monitor.Register.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Register::release_id() {
  // @@protoc_insertion_point(field_release:monitor.Register.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:monitor.Register.id)
}

// optional string blockchain_version = 2;
inline void Register::clear_blockchain_version() {
  blockchain_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Register::blockchain_version() const {
  // @@protoc_insertion_point(field_get:monitor.Register.blockchain_version)
  return blockchain_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_blockchain_version(const ::std::string& value) {
  
  blockchain_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.Register.blockchain_version)
}
inline void Register::set_blockchain_version(const char* value) {
  
  blockchain_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.Register.blockchain_version)
}
inline void Register::set_blockchain_version(const char* value, size_t size) {
  
  blockchain_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.Register.blockchain_version)
}
inline ::std::string* Register::mutable_blockchain_version() {
  
  // @@protoc_insertion_point(field_mutable:monitor.Register.blockchain_version)
  return blockchain_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Register::release_blockchain_version() {
  // @@protoc_insertion_point(field_release:monitor.Register.blockchain_version)
  
  return blockchain_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_allocated_blockchain_version(::std::string* blockchain_version) {
  if (blockchain_version != NULL) {
    
  } else {
    
  }
  blockchain_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blockchain_version);
  // @@protoc_insertion_point(field_set_allocated:monitor.Register.blockchain_version)
}

// optional int64 data_version = 3;
inline void Register::clear_data_version() {
  data_version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Register::data_version() const {
  // @@protoc_insertion_point(field_get:monitor.Register.data_version)
  return data_version_;
}
inline void Register::set_data_version(::google::protobuf::int64 value) {
  
  data_version_ = value;
  // @@protoc_insertion_point(field_set:monitor.Register.data_version)
}

// optional int64 timestamp = 4;
inline void Register::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Register::timestamp() const {
  // @@protoc_insertion_point(field_get:monitor.Register.timestamp)
  return timestamp_;
}
inline void Register::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:monitor.Register.timestamp)
}

// -------------------------------------------------------------------

// Peer

// optional string id = 1;
inline void Peer::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Peer::id() const {
  // @@protoc_insertion_point(field_get:monitor.Peer.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Peer::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.Peer.id)
}
inline void Peer::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.Peer.id)
}
inline void Peer::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.Peer.id)
}
inline ::std::string* Peer::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:monitor.Peer.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Peer::release_id() {
  // @@protoc_insertion_point(field_release:monitor.Peer.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Peer::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:monitor.Peer.id)
}

// optional int64 delay = 2;
inline void Peer::clear_delay() {
  delay_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Peer::delay() const {
  // @@protoc_insertion_point(field_get:monitor.Peer.delay)
  return delay_;
}
inline void Peer::set_delay(::google::protobuf::int64 value) {
  
  delay_ = value;
  // @@protoc_insertion_point(field_set:monitor.Peer.delay)
}

// optional bool active = 3;
inline void Peer::clear_active() {
  active_ = false;
}
inline bool Peer::active() const {
  // @@protoc_insertion_point(field_get:monitor.Peer.active)
  return active_;
}
inline void Peer::set_active(bool value) {
  
  active_ = value;
  // @@protoc_insertion_point(field_set:monitor.Peer.active)
}

// optional string ip_address = 4;
inline void Peer::clear_ip_address() {
  ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Peer::ip_address() const {
  // @@protoc_insertion_point(field_get:monitor.Peer.ip_address)
  return ip_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Peer::set_ip_address(const ::std::string& value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.Peer.ip_address)
}
inline void Peer::set_ip_address(const char* value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.Peer.ip_address)
}
inline void Peer::set_ip_address(const char* value, size_t size) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.Peer.ip_address)
}
inline ::std::string* Peer::mutable_ip_address() {
  
  // @@protoc_insertion_point(field_mutable:monitor.Peer.ip_address)
  return ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Peer::release_ip_address() {
  // @@protoc_insertion_point(field_release:monitor.Peer.ip_address)
  
  return ip_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Peer::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address != NULL) {
    
  } else {
    
  }
  ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_address);
  // @@protoc_insertion_point(field_set_allocated:monitor.Peer.ip_address)
}

// -------------------------------------------------------------------

// GlueManager

// optional string system_current_time = 1;
inline void GlueManager::clear_system_current_time() {
  system_current_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GlueManager::system_current_time() const {
  // @@protoc_insertion_point(field_get:monitor.GlueManager.system_current_time)
  return system_current_time_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GlueManager::set_system_current_time(const ::std::string& value) {
  
  system_current_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.GlueManager.system_current_time)
}
inline void GlueManager::set_system_current_time(const char* value) {
  
  system_current_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.GlueManager.system_current_time)
}
inline void GlueManager::set_system_current_time(const char* value, size_t size) {
  
  system_current_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.GlueManager.system_current_time)
}
inline ::std::string* GlueManager::mutable_system_current_time() {
  
  // @@protoc_insertion_point(field_mutable:monitor.GlueManager.system_current_time)
  return system_current_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GlueManager::release_system_current_time() {
  // @@protoc_insertion_point(field_release:monitor.GlueManager.system_current_time)
  
  return system_current_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GlueManager::set_allocated_system_current_time(::std::string* system_current_time) {
  if (system_current_time != NULL) {
    
  } else {
    
  }
  system_current_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system_current_time);
  // @@protoc_insertion_point(field_set_allocated:monitor.GlueManager.system_current_time)
}

// optional string process_uptime = 2;
inline void GlueManager::clear_process_uptime() {
  process_uptime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GlueManager::process_uptime() const {
  // @@protoc_insertion_point(field_get:monitor.GlueManager.process_uptime)
  return process_uptime_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GlueManager::set_process_uptime(const ::std::string& value) {
  
  process_uptime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.GlueManager.process_uptime)
}
inline void GlueManager::set_process_uptime(const char* value) {
  
  process_uptime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.GlueManager.process_uptime)
}
inline void GlueManager::set_process_uptime(const char* value, size_t size) {
  
  process_uptime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.GlueManager.process_uptime)
}
inline ::std::string* GlueManager::mutable_process_uptime() {
  
  // @@protoc_insertion_point(field_mutable:monitor.GlueManager.process_uptime)
  return process_uptime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GlueManager::release_process_uptime() {
  // @@protoc_insertion_point(field_release:monitor.GlueManager.process_uptime)
  
  return process_uptime_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GlueManager::set_allocated_process_uptime(::std::string* process_uptime) {
  if (process_uptime != NULL) {
    
  } else {
    
  }
  process_uptime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), process_uptime);
  // @@protoc_insertion_point(field_set_allocated:monitor.GlueManager.process_uptime)
}

// optional string system_uptime = 3;
inline void GlueManager::clear_system_uptime() {
  system_uptime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GlueManager::system_uptime() const {
  // @@protoc_insertion_point(field_get:monitor.GlueManager.system_uptime)
  return system_uptime_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GlueManager::set_system_uptime(const ::std::string& value) {
  
  system_uptime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.GlueManager.system_uptime)
}
inline void GlueManager::set_system_uptime(const char* value) {
  
  system_uptime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.GlueManager.system_uptime)
}
inline void GlueManager::set_system_uptime(const char* value, size_t size) {
  
  system_uptime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.GlueManager.system_uptime)
}
inline ::std::string* GlueManager::mutable_system_uptime() {
  
  // @@protoc_insertion_point(field_mutable:monitor.GlueManager.system_uptime)
  return system_uptime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GlueManager::release_system_uptime() {
  // @@protoc_insertion_point(field_release:monitor.GlueManager.system_uptime)
  
  return system_uptime_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GlueManager::set_allocated_system_uptime(::std::string* system_uptime) {
  if (system_uptime != NULL) {
    
  } else {
    
  }
  system_uptime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system_uptime);
  // @@protoc_insertion_point(field_set_allocated:monitor.GlueManager.system_uptime)
}

// -------------------------------------------------------------------

// PeerManager

// optional string peer_id = 1;
inline void PeerManager::clear_peer_id() {
  peer_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PeerManager::peer_id() const {
  // @@protoc_insertion_point(field_get:monitor.PeerManager.peer_id)
  return peer_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PeerManager::set_peer_id(const ::std::string& value) {
  
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.PeerManager.peer_id)
}
inline void PeerManager::set_peer_id(const char* value) {
  
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.PeerManager.peer_id)
}
inline void PeerManager::set_peer_id(const char* value, size_t size) {
  
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.PeerManager.peer_id)
}
inline ::std::string* PeerManager::mutable_peer_id() {
  
  // @@protoc_insertion_point(field_mutable:monitor.PeerManager.peer_id)
  return peer_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PeerManager::release_peer_id() {
  // @@protoc_insertion_point(field_release:monitor.PeerManager.peer_id)
  
  return peer_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PeerManager::set_allocated_peer_id(::std::string* peer_id) {
  if (peer_id != NULL) {
    
  } else {
    
  }
  peer_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer_id);
  // @@protoc_insertion_point(field_set_allocated:monitor.PeerManager.peer_id)
}

// repeated .monitor.Peer peer = 2;
inline int PeerManager::peer_size() const {
  return peer_.size();
}
inline void PeerManager::clear_peer() {
  peer_.Clear();
}
inline const ::monitor::Peer& PeerManager::peer(int index) const {
  // @@protoc_insertion_point(field_get:monitor.PeerManager.peer)
  return peer_.Get(index);
}
inline ::monitor::Peer* PeerManager::mutable_peer(int index) {
  // @@protoc_insertion_point(field_mutable:monitor.PeerManager.peer)
  return peer_.Mutable(index);
}
inline ::monitor::Peer* PeerManager::add_peer() {
  // @@protoc_insertion_point(field_add:monitor.PeerManager.peer)
  return peer_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::monitor::Peer >*
PeerManager::mutable_peer() {
  // @@protoc_insertion_point(field_mutable_list:monitor.PeerManager.peer)
  return &peer_;
}
inline const ::google::protobuf::RepeatedPtrField< ::monitor::Peer >&
PeerManager::peer() const {
  // @@protoc_insertion_point(field_list:monitor.PeerManager.peer)
  return peer_;
}

// -------------------------------------------------------------------

// PhantomStatus

// optional .monitor.GlueManager glue_manager = 1;
inline bool PhantomStatus::has_glue_manager() const {
  return !_is_default_instance_ && glue_manager_ != NULL;
}
inline void PhantomStatus::clear_glue_manager() {
  if (GetArenaNoVirtual() == NULL && glue_manager_ != NULL) delete glue_manager_;
  glue_manager_ = NULL;
}
inline const ::monitor::GlueManager& PhantomStatus::glue_manager() const {
  // @@protoc_insertion_point(field_get:monitor.PhantomStatus.glue_manager)
  return glue_manager_ != NULL ? *glue_manager_ : *default_instance_->glue_manager_;
}
inline ::monitor::GlueManager* PhantomStatus::mutable_glue_manager() {
  
  if (glue_manager_ == NULL) {
    glue_manager_ = new ::monitor::GlueManager;
  }
  // @@protoc_insertion_point(field_mutable:monitor.PhantomStatus.glue_manager)
  return glue_manager_;
}
inline ::monitor::GlueManager* PhantomStatus::release_glue_manager() {
  // @@protoc_insertion_point(field_release:monitor.PhantomStatus.glue_manager)
  
  ::monitor::GlueManager* temp = glue_manager_;
  glue_manager_ = NULL;
  return temp;
}
inline void PhantomStatus::set_allocated_glue_manager(::monitor::GlueManager* glue_manager) {
  delete glue_manager_;
  glue_manager_ = glue_manager;
  if (glue_manager) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.PhantomStatus.glue_manager)
}

// optional .monitor.PeerManager peer_manager = 2;
inline bool PhantomStatus::has_peer_manager() const {
  return !_is_default_instance_ && peer_manager_ != NULL;
}
inline void PhantomStatus::clear_peer_manager() {
  if (GetArenaNoVirtual() == NULL && peer_manager_ != NULL) delete peer_manager_;
  peer_manager_ = NULL;
}
inline const ::monitor::PeerManager& PhantomStatus::peer_manager() const {
  // @@protoc_insertion_point(field_get:monitor.PhantomStatus.peer_manager)
  return peer_manager_ != NULL ? *peer_manager_ : *default_instance_->peer_manager_;
}
inline ::monitor::PeerManager* PhantomStatus::mutable_peer_manager() {
  
  if (peer_manager_ == NULL) {
    peer_manager_ = new ::monitor::PeerManager;
  }
  // @@protoc_insertion_point(field_mutable:monitor.PhantomStatus.peer_manager)
  return peer_manager_;
}
inline ::monitor::PeerManager* PhantomStatus::release_peer_manager() {
  // @@protoc_insertion_point(field_release:monitor.PhantomStatus.peer_manager)
  
  ::monitor::PeerManager* temp = peer_manager_;
  peer_manager_ = NULL;
  return temp;
}
inline void PhantomStatus::set_allocated_peer_manager(::monitor::PeerManager* peer_manager) {
  delete peer_manager_;
  peer_manager_ = peer_manager;
  if (peer_manager) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.PhantomStatus.peer_manager)
}

// -------------------------------------------------------------------

// LedgerStatus

// optional .protocol.LedgerHeader ledger_header = 1;
inline bool LedgerStatus::has_ledger_header() const {
  return !_is_default_instance_ && ledger_header_ != NULL;
}
inline void LedgerStatus::clear_ledger_header() {
  if (GetArenaNoVirtual() == NULL && ledger_header_ != NULL) delete ledger_header_;
  ledger_header_ = NULL;
}
inline const ::protocol::LedgerHeader& LedgerStatus::ledger_header() const {
  // @@protoc_insertion_point(field_get:monitor.LedgerStatus.ledger_header)
  return ledger_header_ != NULL ? *ledger_header_ : *default_instance_->ledger_header_;
}
inline ::protocol::LedgerHeader* LedgerStatus::mutable_ledger_header() {
  
  if (ledger_header_ == NULL) {
    ledger_header_ = new ::protocol::LedgerHeader;
  }
  // @@protoc_insertion_point(field_mutable:monitor.LedgerStatus.ledger_header)
  return ledger_header_;
}
inline ::protocol::LedgerHeader* LedgerStatus::release_ledger_header() {
  // @@protoc_insertion_point(field_release:monitor.LedgerStatus.ledger_header)
  
  ::protocol::LedgerHeader* temp = ledger_header_;
  ledger_header_ = NULL;
  return temp;
}
inline void LedgerStatus::set_allocated_ledger_header(::protocol::LedgerHeader* ledger_header) {
  delete ledger_header_;
  ledger_header_ = ledger_header;
  if (ledger_header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.LedgerStatus.ledger_header)
}

// optional int64 transaction_size = 2;
inline void LedgerStatus::clear_transaction_size() {
  transaction_size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LedgerStatus::transaction_size() const {
  // @@protoc_insertion_point(field_get:monitor.LedgerStatus.transaction_size)
  return transaction_size_;
}
inline void LedgerStatus::set_transaction_size(::google::protobuf::int64 value) {
  
  transaction_size_ = value;
  // @@protoc_insertion_point(field_set:monitor.LedgerStatus.transaction_size)
}

// optional int64 account_count = 3;
inline void LedgerStatus::clear_account_count() {
  account_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LedgerStatus::account_count() const {
  // @@protoc_insertion_point(field_get:monitor.LedgerStatus.account_count)
  return account_count_;
}
inline void LedgerStatus::set_account_count(::google::protobuf::int64 value) {
  
  account_count_ = value;
  // @@protoc_insertion_point(field_set:monitor.LedgerStatus.account_count)
}

// optional int64 timestamp = 4;
inline void LedgerStatus::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LedgerStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:monitor.LedgerStatus.timestamp)
  return timestamp_;
}
inline void LedgerStatus::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:monitor.LedgerStatus.timestamp)
}

// -------------------------------------------------------------------

// SystemProperty

// optional string host_name = 1;
inline void SystemProperty::clear_host_name() {
  host_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SystemProperty::host_name() const {
  // @@protoc_insertion_point(field_get:monitor.SystemProperty.host_name)
  return host_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemProperty::set_host_name(const ::std::string& value) {
  
  host_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.SystemProperty.host_name)
}
inline void SystemProperty::set_host_name(const char* value) {
  
  host_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.SystemProperty.host_name)
}
inline void SystemProperty::set_host_name(const char* value, size_t size) {
  
  host_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.SystemProperty.host_name)
}
inline ::std::string* SystemProperty::mutable_host_name() {
  
  // @@protoc_insertion_point(field_mutable:monitor.SystemProperty.host_name)
  return host_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemProperty::release_host_name() {
  // @@protoc_insertion_point(field_release:monitor.SystemProperty.host_name)
  
  return host_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemProperty::set_allocated_host_name(::std::string* host_name) {
  if (host_name != NULL) {
    
  } else {
    
  }
  host_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_name);
  // @@protoc_insertion_point(field_set_allocated:monitor.SystemProperty.host_name)
}

// optional string os_version = 2;
inline void SystemProperty::clear_os_version() {
  os_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SystemProperty::os_version() const {
  // @@protoc_insertion_point(field_get:monitor.SystemProperty.os_version)
  return os_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemProperty::set_os_version(const ::std::string& value) {
  
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.SystemProperty.os_version)
}
inline void SystemProperty::set_os_version(const char* value) {
  
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.SystemProperty.os_version)
}
inline void SystemProperty::set_os_version(const char* value, size_t size) {
  
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.SystemProperty.os_version)
}
inline ::std::string* SystemProperty::mutable_os_version() {
  
  // @@protoc_insertion_point(field_mutable:monitor.SystemProperty.os_version)
  return os_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemProperty::release_os_version() {
  // @@protoc_insertion_point(field_release:monitor.SystemProperty.os_version)
  
  return os_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemProperty::set_allocated_os_version(::std::string* os_version) {
  if (os_version != NULL) {
    
  } else {
    
  }
  os_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_version);
  // @@protoc_insertion_point(field_set_allocated:monitor.SystemProperty.os_version)
}

// optional int64 startup_time = 3;
inline void SystemProperty::clear_startup_time() {
  startup_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SystemProperty::startup_time() const {
  // @@protoc_insertion_point(field_get:monitor.SystemProperty.startup_time)
  return startup_time_;
}
inline void SystemProperty::set_startup_time(::google::protobuf::int64 value) {
  
  startup_time_ = value;
  // @@protoc_insertion_point(field_set:monitor.SystemProperty.startup_time)
}

// optional string os_bit = 4;
inline void SystemProperty::clear_os_bit() {
  os_bit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SystemProperty::os_bit() const {
  // @@protoc_insertion_point(field_get:monitor.SystemProperty.os_bit)
  return os_bit_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemProperty::set_os_bit(const ::std::string& value) {
  
  os_bit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.SystemProperty.os_bit)
}
inline void SystemProperty::set_os_bit(const char* value) {
  
  os_bit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.SystemProperty.os_bit)
}
inline void SystemProperty::set_os_bit(const char* value, size_t size) {
  
  os_bit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.SystemProperty.os_bit)
}
inline ::std::string* SystemProperty::mutable_os_bit() {
  
  // @@protoc_insertion_point(field_mutable:monitor.SystemProperty.os_bit)
  return os_bit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemProperty::release_os_bit() {
  // @@protoc_insertion_point(field_release:monitor.SystemProperty.os_bit)
  
  return os_bit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemProperty::set_allocated_os_bit(::std::string* os_bit) {
  if (os_bit != NULL) {
    
  } else {
    
  }
  os_bit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_bit);
  // @@protoc_insertion_point(field_set_allocated:monitor.SystemProperty.os_bit)
}

// -------------------------------------------------------------------

// SystemResource

// optional int64 available = 1;
inline void SystemResource::clear_available() {
  available_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SystemResource::available() const {
  // @@protoc_insertion_point(field_get:monitor.SystemResource.available)
  return available_;
}
inline void SystemResource::set_available(::google::protobuf::int64 value) {
  
  available_ = value;
  // @@protoc_insertion_point(field_set:monitor.SystemResource.available)
}

// optional int64 total = 2;
inline void SystemResource::clear_total() {
  total_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SystemResource::total() const {
  // @@protoc_insertion_point(field_get:monitor.SystemResource.total)
  return total_;
}
inline void SystemResource::set_total(::google::protobuf::int64 value) {
  
  total_ = value;
  // @@protoc_insertion_point(field_set:monitor.SystemResource.total)
}

// optional double used_percent = 3;
inline void SystemResource::clear_used_percent() {
  used_percent_ = 0;
}
inline double SystemResource::used_percent() const {
  // @@protoc_insertion_point(field_get:monitor.SystemResource.used_percent)
  return used_percent_;
}
inline void SystemResource::set_used_percent(double value) {
  
  used_percent_ = value;
  // @@protoc_insertion_point(field_set:monitor.SystemResource.used_percent)
}

// optional string description = 4;
inline void SystemResource::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SystemResource::description() const {
  // @@protoc_insertion_point(field_get:monitor.SystemResource.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemResource::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.SystemResource.description)
}
inline void SystemResource::set_description(const char* value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.SystemResource.description)
}
inline void SystemResource::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.SystemResource.description)
}
inline ::std::string* SystemResource::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:monitor.SystemResource.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemResource::release_description() {
  // @@protoc_insertion_point(field_release:monitor.SystemResource.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemResource::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:monitor.SystemResource.description)
}

// -------------------------------------------------------------------

// Partition

// optional int64 total_bytes = 1;
inline void Partition::clear_total_bytes() {
  total_bytes_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Partition::total_bytes() const {
  // @@protoc_insertion_point(field_get:monitor.Partition.total_bytes)
  return total_bytes_;
}
inline void Partition::set_total_bytes(::google::protobuf::int64 value) {
  
  total_bytes_ = value;
  // @@protoc_insertion_point(field_set:monitor.Partition.total_bytes)
}

// repeated .monitor.SystemResource partition = 2;
inline int Partition::partition_size() const {
  return partition_.size();
}
inline void Partition::clear_partition() {
  partition_.Clear();
}
inline const ::monitor::SystemResource& Partition::partition(int index) const {
  // @@protoc_insertion_point(field_get:monitor.Partition.partition)
  return partition_.Get(index);
}
inline ::monitor::SystemResource* Partition::mutable_partition(int index) {
  // @@protoc_insertion_point(field_mutable:monitor.Partition.partition)
  return partition_.Mutable(index);
}
inline ::monitor::SystemResource* Partition::add_partition() {
  // @@protoc_insertion_point(field_add:monitor.Partition.partition)
  return partition_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::monitor::SystemResource >*
Partition::mutable_partition() {
  // @@protoc_insertion_point(field_mutable_list:monitor.Partition.partition)
  return &partition_;
}
inline const ::google::protobuf::RepeatedPtrField< ::monitor::SystemResource >&
Partition::partition() const {
  // @@protoc_insertion_point(field_list:monitor.Partition.partition)
  return partition_;
}

// -------------------------------------------------------------------

// CPU

// optional double used_percent = 1;
inline void CPU::clear_used_percent() {
  used_percent_ = 0;
}
inline double CPU::used_percent() const {
  // @@protoc_insertion_point(field_get:monitor.CPU.used_percent)
  return used_percent_;
}
inline void CPU::set_used_percent(double value) {
  
  used_percent_ = value;
  // @@protoc_insertion_point(field_set:monitor.CPU.used_percent)
}

// -------------------------------------------------------------------

// SystemStatus

// optional .monitor.SystemProperty property = 1;
inline bool SystemStatus::has_property() const {
  return !_is_default_instance_ && property_ != NULL;
}
inline void SystemStatus::clear_property() {
  if (GetArenaNoVirtual() == NULL && property_ != NULL) delete property_;
  property_ = NULL;
}
inline const ::monitor::SystemProperty& SystemStatus::property() const {
  // @@protoc_insertion_point(field_get:monitor.SystemStatus.property)
  return property_ != NULL ? *property_ : *default_instance_->property_;
}
inline ::monitor::SystemProperty* SystemStatus::mutable_property() {
  
  if (property_ == NULL) {
    property_ = new ::monitor::SystemProperty;
  }
  // @@protoc_insertion_point(field_mutable:monitor.SystemStatus.property)
  return property_;
}
inline ::monitor::SystemProperty* SystemStatus::release_property() {
  // @@protoc_insertion_point(field_release:monitor.SystemStatus.property)
  
  ::monitor::SystemProperty* temp = property_;
  property_ = NULL;
  return temp;
}
inline void SystemStatus::set_allocated_property(::monitor::SystemProperty* property) {
  delete property_;
  property_ = property;
  if (property) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.SystemStatus.property)
}

// optional .monitor.SystemResource memory = 2;
inline bool SystemStatus::has_memory() const {
  return !_is_default_instance_ && memory_ != NULL;
}
inline void SystemStatus::clear_memory() {
  if (GetArenaNoVirtual() == NULL && memory_ != NULL) delete memory_;
  memory_ = NULL;
}
inline const ::monitor::SystemResource& SystemStatus::memory() const {
  // @@protoc_insertion_point(field_get:monitor.SystemStatus.memory)
  return memory_ != NULL ? *memory_ : *default_instance_->memory_;
}
inline ::monitor::SystemResource* SystemStatus::mutable_memory() {
  
  if (memory_ == NULL) {
    memory_ = new ::monitor::SystemResource;
  }
  // @@protoc_insertion_point(field_mutable:monitor.SystemStatus.memory)
  return memory_;
}
inline ::monitor::SystemResource* SystemStatus::release_memory() {
  // @@protoc_insertion_point(field_release:monitor.SystemStatus.memory)
  
  ::monitor::SystemResource* temp = memory_;
  memory_ = NULL;
  return temp;
}
inline void SystemStatus::set_allocated_memory(::monitor::SystemResource* memory) {
  delete memory_;
  memory_ = memory;
  if (memory) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.SystemStatus.memory)
}

// optional .monitor.CPU cpu = 3;
inline bool SystemStatus::has_cpu() const {
  return !_is_default_instance_ && cpu_ != NULL;
}
inline void SystemStatus::clear_cpu() {
  if (GetArenaNoVirtual() == NULL && cpu_ != NULL) delete cpu_;
  cpu_ = NULL;
}
inline const ::monitor::CPU& SystemStatus::cpu() const {
  // @@protoc_insertion_point(field_get:monitor.SystemStatus.cpu)
  return cpu_ != NULL ? *cpu_ : *default_instance_->cpu_;
}
inline ::monitor::CPU* SystemStatus::mutable_cpu() {
  
  if (cpu_ == NULL) {
    cpu_ = new ::monitor::CPU;
  }
  // @@protoc_insertion_point(field_mutable:monitor.SystemStatus.cpu)
  return cpu_;
}
inline ::monitor::CPU* SystemStatus::release_cpu() {
  // @@protoc_insertion_point(field_release:monitor.SystemStatus.cpu)
  
  ::monitor::CPU* temp = cpu_;
  cpu_ = NULL;
  return temp;
}
inline void SystemStatus::set_allocated_cpu(::monitor::CPU* cpu) {
  delete cpu_;
  cpu_ = cpu;
  if (cpu) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.SystemStatus.cpu)
}

// optional .monitor.Partition partitions = 4;
inline bool SystemStatus::has_partitions() const {
  return !_is_default_instance_ && partitions_ != NULL;
}
inline void SystemStatus::clear_partitions() {
  if (GetArenaNoVirtual() == NULL && partitions_ != NULL) delete partitions_;
  partitions_ = NULL;
}
inline const ::monitor::Partition& SystemStatus::partitions() const {
  // @@protoc_insertion_point(field_get:monitor.SystemStatus.partitions)
  return partitions_ != NULL ? *partitions_ : *default_instance_->partitions_;
}
inline ::monitor::Partition* SystemStatus::mutable_partitions() {
  
  if (partitions_ == NULL) {
    partitions_ = new ::monitor::Partition;
  }
  // @@protoc_insertion_point(field_mutable:monitor.SystemStatus.partitions)
  return partitions_;
}
inline ::monitor::Partition* SystemStatus::release_partitions() {
  // @@protoc_insertion_point(field_release:monitor.SystemStatus.partitions)
  
  ::monitor::Partition* temp = partitions_;
  partitions_ = NULL;
  return temp;
}
inline void SystemStatus::set_allocated_partitions(::monitor::Partition* partitions) {
  delete partitions_;
  partitions_ = partitions;
  if (partitions) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.SystemStatus.partitions)
}

// -------------------------------------------------------------------

// AlertStatus

// optional int64 ledger_sequence = 1;
inline void AlertStatus::clear_ledger_sequence() {
  ledger_sequence_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AlertStatus::ledger_sequence() const {
  // @@protoc_insertion_point(field_get:monitor.AlertStatus.ledger_sequence)
  return ledger_sequence_;
}
inline void AlertStatus::set_ledger_sequence(::google::protobuf::int64 value) {
  
  ledger_sequence_ = value;
  // @@protoc_insertion_point(field_set:monitor.AlertStatus.ledger_sequence)
}

// optional string node_id = 2;
inline void AlertStatus::clear_node_id() {
  node_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AlertStatus::node_id() const {
  // @@protoc_insertion_point(field_get:monitor.AlertStatus.node_id)
  return node_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AlertStatus::set_node_id(const ::std::string& value) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:monitor.AlertStatus.node_id)
}
inline void AlertStatus::set_node_id(const char* value) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:monitor.AlertStatus.node_id)
}
inline void AlertStatus::set_node_id(const char* value, size_t size) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:monitor.AlertStatus.node_id)
}
inline ::std::string* AlertStatus::mutable_node_id() {
  
  // @@protoc_insertion_point(field_mutable:monitor.AlertStatus.node_id)
  return node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AlertStatus::release_node_id() {
  // @@protoc_insertion_point(field_release:monitor.AlertStatus.node_id)
  
  return node_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AlertStatus::set_allocated_node_id(::std::string* node_id) {
  if (node_id != NULL) {
    
  } else {
    
  }
  node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_id);
  // @@protoc_insertion_point(field_set_allocated:monitor.AlertStatus.node_id)
}

// optional .monitor.SystemStatus system = 3;
inline bool AlertStatus::has_system() const {
  return !_is_default_instance_ && system_ != NULL;
}
inline void AlertStatus::clear_system() {
  if (GetArenaNoVirtual() == NULL && system_ != NULL) delete system_;
  system_ = NULL;
}
inline const ::monitor::SystemStatus& AlertStatus::system() const {
  // @@protoc_insertion_point(field_get:monitor.AlertStatus.system)
  return system_ != NULL ? *system_ : *default_instance_->system_;
}
inline ::monitor::SystemStatus* AlertStatus::mutable_system() {
  
  if (system_ == NULL) {
    system_ = new ::monitor::SystemStatus;
  }
  // @@protoc_insertion_point(field_mutable:monitor.AlertStatus.system)
  return system_;
}
inline ::monitor::SystemStatus* AlertStatus::release_system() {
  // @@protoc_insertion_point(field_release:monitor.AlertStatus.system)
  
  ::monitor::SystemStatus* temp = system_;
  system_ = NULL;
  return temp;
}
inline void AlertStatus::set_allocated_system(::monitor::SystemStatus* system) {
  delete system_;
  system_ = system;
  if (system) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:monitor.AlertStatus.system)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace monitor

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::monitor::MONITOR_MESSAGE_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::monitor::MONITOR_MESSAGE_TYPE>() {
  return ::monitor::MONITOR_MESSAGE_TYPE_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_monitor_2eproto__INCLUDED
