// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chain.proto

#ifndef PROTOBUF_chain_2eproto__INCLUDED
#define PROTOBUF_chain_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace protocol {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_chain_2eproto();
void protobuf_AssignDesc_chain_2eproto();
void protobuf_ShutdownFile_chain_2eproto();

class Account;
class AccountPrivilege;
class AccountThreshold;
class Asset;
class AssetKey;
class AssetProperty;
class AssetStore;
class ConsensusValue;
class ConsensusValueValidation;
class Contract;
class Ledger;
class LedgerHeader;
class Operation;
class OperationCreateAccount;
class OperationIssueAsset;
class OperationLog;
class OperationPayAsset;
class OperationPayCoin;
class OperationSetMetadata;
class OperationSetPrivilege;
class OperationSetSignerWeight;
class OperationSetThreshold;
class OperationTypeThreshold;
class Signer;
class Transaction;
class TransactionEnv;
class TransactionEnvSet;
class TransactionEnvStore;
class Trigger;
class Trigger_OperationTrigger;

enum Operation_Type {
  Operation_Type_UNKNOWN = 0,
  Operation_Type_CREATE_ACCOUNT = 1,
  Operation_Type_ISSUE_ASSET = 2,
  Operation_Type_PAY_ASSET = 3,
  Operation_Type_SET_METADATA = 4,
  Operation_Type_SET_SIGNER_WEIGHT = 5,
  Operation_Type_SET_THRESHOLD = 6,
  Operation_Type_PAY_COIN = 7,
  Operation_Type_LOG = 8,
  Operation_Type_SET_PRIVILEGE = 9,
  Operation_Type_Operation_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Operation_Type_Operation_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Operation_Type_IsValid(int value);
const Operation_Type Operation_Type_Type_MIN = Operation_Type_UNKNOWN;
const Operation_Type Operation_Type_Type_MAX = Operation_Type_SET_PRIVILEGE;
const int Operation_Type_Type_ARRAYSIZE = Operation_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Operation_Type_descriptor();
inline const ::std::string& Operation_Type_Name(Operation_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Operation_Type_descriptor(), value);
}
inline bool Operation_Type_Parse(
    const ::std::string& name, Operation_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Operation_Type>(
    Operation_Type_descriptor(), name, value);
}
enum Transaction_Limit {
  Transaction_Limit_UNKNOWN = 0,
  Transaction_Limit_OPERATIONS = 1000,
  Transaction_Limit_Transaction_Limit_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Transaction_Limit_Transaction_Limit_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Transaction_Limit_IsValid(int value);
const Transaction_Limit Transaction_Limit_Limit_MIN = Transaction_Limit_UNKNOWN;
const Transaction_Limit Transaction_Limit_Limit_MAX = Transaction_Limit_OPERATIONS;
const int Transaction_Limit_Limit_ARRAYSIZE = Transaction_Limit_Limit_MAX + 1;

const ::google::protobuf::EnumDescriptor* Transaction_Limit_descriptor();
inline const ::std::string& Transaction_Limit_Name(Transaction_Limit value) {
  return ::google::protobuf::internal::NameOfEnum(
    Transaction_Limit_descriptor(), value);
}
inline bool Transaction_Limit_Parse(
    const ::std::string& name, Transaction_Limit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Transaction_Limit>(
    Transaction_Limit_descriptor(), name, value);
}
enum Signer_Limit {
  Signer_Limit_SIGNER_NONE = 0,
  Signer_Limit_SIGNER = 100,
  Signer_Limit_Signer_Limit_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Signer_Limit_Signer_Limit_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Signer_Limit_IsValid(int value);
const Signer_Limit Signer_Limit_Limit_MIN = Signer_Limit_SIGNER_NONE;
const Signer_Limit Signer_Limit_Limit_MAX = Signer_Limit_SIGNER;
const int Signer_Limit_Limit_ARRAYSIZE = Signer_Limit_Limit_MAX + 1;

const ::google::protobuf::EnumDescriptor* Signer_Limit_descriptor();
inline const ::std::string& Signer_Limit_Name(Signer_Limit value) {
  return ::google::protobuf::internal::NameOfEnum(
    Signer_Limit_descriptor(), value);
}
inline bool Signer_Limit_Parse(
    const ::std::string& name, Signer_Limit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Signer_Limit>(
    Signer_Limit_descriptor(), name, value);
}
enum Trigger_TransactionType {
  Trigger_TransactionType_NORMAL_TRANSACTION = 0,
  Trigger_TransactionType_CONTRACT_TRANSACTION = 1,
  Trigger_TransactionType_Trigger_TransactionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Trigger_TransactionType_Trigger_TransactionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Trigger_TransactionType_IsValid(int value);
const Trigger_TransactionType Trigger_TransactionType_TransactionType_MIN = Trigger_TransactionType_NORMAL_TRANSACTION;
const Trigger_TransactionType Trigger_TransactionType_TransactionType_MAX = Trigger_TransactionType_CONTRACT_TRANSACTION;
const int Trigger_TransactionType_TransactionType_ARRAYSIZE = Trigger_TransactionType_TransactionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Trigger_TransactionType_descriptor();
inline const ::std::string& Trigger_TransactionType_Name(Trigger_TransactionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Trigger_TransactionType_descriptor(), value);
}
inline bool Trigger_TransactionType_Parse(
    const ::std::string& name, Trigger_TransactionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Trigger_TransactionType>(
    Trigger_TransactionType_descriptor(), name, value);
}
enum Contract_ContractType {
  Contract_ContractType_JAVASCRIPT = 0,
  Contract_ContractType_Contract_ContractType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Contract_ContractType_Contract_ContractType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Contract_ContractType_IsValid(int value);
const Contract_ContractType Contract_ContractType_ContractType_MIN = Contract_ContractType_JAVASCRIPT;
const Contract_ContractType Contract_ContractType_ContractType_MAX = Contract_ContractType_JAVASCRIPT;
const int Contract_ContractType_ContractType_ARRAYSIZE = Contract_ContractType_ContractType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Contract_ContractType_descriptor();
inline const ::std::string& Contract_ContractType_Name(Contract_ContractType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Contract_ContractType_descriptor(), value);
}
inline bool Contract_ContractType_Parse(
    const ::std::string& name, Contract_ContractType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Contract_ContractType>(
    Contract_ContractType_descriptor(), name, value);
}
enum Limit {
  UNKNOWN = 0,
  SIGNATURE = 100,
  Limit_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Limit_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Limit_IsValid(int value);
const Limit Limit_MIN = UNKNOWN;
const Limit Limit_MAX = SIGNATURE;
const int Limit_ARRAYSIZE = Limit_MAX + 1;

const ::google::protobuf::EnumDescriptor* Limit_descriptor();
inline const ::std::string& Limit_Name(Limit value) {
  return ::google::protobuf::internal::NameOfEnum(
    Limit_descriptor(), value);
}
inline bool Limit_Parse(
    const ::std::string& name, Limit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Limit>(
    Limit_descriptor(), name, value);
}
// ===================================================================

class Account : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Account) */ {
 public:
  Account();
  virtual ~Account();

  Account(const Account& from);

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Account& default_instance();

  void Swap(Account* other);

  // implements Message ----------------------------------------------

  inline Account* New() const { return New(NULL); }

  Account* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Account* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional int64 nonce = 2;
  void clear_nonce();
  static const int kNonceFieldNumber = 2;
  ::google::protobuf::int64 nonce() const;
  void set_nonce(::google::protobuf::int64 value);

  // optional .protocol.AccountPrivilege priv = 3;
  bool has_priv() const;
  void clear_priv();
  static const int kPrivFieldNumber = 3;
  const ::protocol::AccountPrivilege& priv() const;
  ::protocol::AccountPrivilege* mutable_priv();
  ::protocol::AccountPrivilege* release_priv();
  void set_allocated_priv(::protocol::AccountPrivilege* priv);

  // optional bytes metadatas_hash = 4;
  void clear_metadatas_hash();
  static const int kMetadatasHashFieldNumber = 4;
  const ::std::string& metadatas_hash() const;
  void set_metadatas_hash(const ::std::string& value);
  void set_metadatas_hash(const char* value);
  void set_metadatas_hash(const void* value, size_t size);
  ::std::string* mutable_metadatas_hash();
  ::std::string* release_metadatas_hash();
  void set_allocated_metadatas_hash(::std::string* metadatas_hash);

  // optional bytes assets_hash = 5;
  void clear_assets_hash();
  static const int kAssetsHashFieldNumber = 5;
  const ::std::string& assets_hash() const;
  void set_assets_hash(const ::std::string& value);
  void set_assets_hash(const char* value);
  void set_assets_hash(const void* value, size_t size);
  ::std::string* mutable_assets_hash();
  ::std::string* release_assets_hash();
  void set_allocated_assets_hash(::std::string* assets_hash);

  // optional .protocol.Contract contract = 6;
  bool has_contract() const;
  void clear_contract();
  static const int kContractFieldNumber = 6;
  const ::protocol::Contract& contract() const;
  ::protocol::Contract* mutable_contract();
  ::protocol::Contract* release_contract();
  void set_allocated_contract(::protocol::Contract* contract);

  // optional int64 balance = 7;
  void clear_balance();
  static const int kBalanceFieldNumber = 7;
  ::google::protobuf::int64 balance() const;
  void set_balance(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.Account)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::int64 nonce_;
  ::protocol::AccountPrivilege* priv_;
  ::google::protobuf::internal::ArenaStringPtr metadatas_hash_;
  ::google::protobuf::internal::ArenaStringPtr assets_hash_;
  ::protocol::Contract* contract_;
  ::google::protobuf::int64 balance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static Account* default_instance_;
};
// -------------------------------------------------------------------

class AssetKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.AssetKey) */ {
 public:
  AssetKey();
  virtual ~AssetKey();

  AssetKey(const AssetKey& from);

  inline AssetKey& operator=(const AssetKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetKey& default_instance();

  void Swap(AssetKey* other);

  // implements Message ----------------------------------------------

  inline AssetKey* New() const { return New(NULL); }

  AssetKey* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssetKey& from);
  void MergeFrom(const AssetKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AssetKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string issuer = 1;
  void clear_issuer();
  static const int kIssuerFieldNumber = 1;
  const ::std::string& issuer() const;
  void set_issuer(const ::std::string& value);
  void set_issuer(const char* value);
  void set_issuer(const char* value, size_t size);
  ::std::string* mutable_issuer();
  ::std::string* release_issuer();
  void set_allocated_issuer(::std::string* issuer);

  // optional string code = 2;
  void clear_code();
  static const int kCodeFieldNumber = 2;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // optional int32 type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.AssetKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr issuer_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  ::google::protobuf::int32 type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static AssetKey* default_instance_;
};
// -------------------------------------------------------------------

class Asset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Asset) */ {
 public:
  Asset();
  virtual ~Asset();

  Asset(const Asset& from);

  inline Asset& operator=(const Asset& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Asset& default_instance();

  void Swap(Asset* other);

  // implements Message ----------------------------------------------

  inline Asset* New() const { return New(NULL); }

  Asset* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Asset& from);
  void MergeFrom(const Asset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Asset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.AssetKey key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::protocol::AssetKey& key() const;
  ::protocol::AssetKey* mutable_key();
  ::protocol::AssetKey* release_key();
  void set_allocated_key(::protocol::AssetKey* key);

  // optional int64 amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.Asset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::protocol::AssetKey* key_;
  ::google::protobuf::int64 amount_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static Asset* default_instance_;
};
// -------------------------------------------------------------------

class AssetProperty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.AssetProperty) */ {
 public:
  AssetProperty();
  virtual ~AssetProperty();

  AssetProperty(const AssetProperty& from);

  inline AssetProperty& operator=(const AssetProperty& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetProperty& default_instance();

  void Swap(AssetProperty* other);

  // implements Message ----------------------------------------------

  inline AssetProperty* New() const { return New(NULL); }

  AssetProperty* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssetProperty& from);
  void MergeFrom(const AssetProperty& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AssetProperty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 decimal = 1;
  void clear_decimal();
  static const int kDecimalFieldNumber = 1;
  ::google::protobuf::int32 decimal() const;
  void set_decimal(::google::protobuf::int32 value);

  // optional string description = 2;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional int64 max_supply = 3;
  void clear_max_supply();
  static const int kMaxSupplyFieldNumber = 3;
  ::google::protobuf::int64 max_supply() const;
  void set_max_supply(::google::protobuf::int64 value);

  // optional int64 issued_amount = 4;
  void clear_issued_amount();
  static const int kIssuedAmountFieldNumber = 4;
  ::google::protobuf::int64 issued_amount() const;
  void set_issued_amount(::google::protobuf::int64 value);

  // optional int32 fee_percent = 5;
  void clear_fee_percent();
  static const int kFeePercentFieldNumber = 5;
  ::google::protobuf::int32 fee_percent() const;
  void set_fee_percent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.AssetProperty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::int64 max_supply_;
  ::google::protobuf::int32 decimal_;
  ::google::protobuf::int32 fee_percent_;
  ::google::protobuf::int64 issued_amount_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static AssetProperty* default_instance_;
};
// -------------------------------------------------------------------

class AssetStore : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.AssetStore) */ {
 public:
  AssetStore();
  virtual ~AssetStore();

  AssetStore(const AssetStore& from);

  inline AssetStore& operator=(const AssetStore& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetStore& default_instance();

  void Swap(AssetStore* other);

  // implements Message ----------------------------------------------

  inline AssetStore* New() const { return New(NULL); }

  AssetStore* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssetStore& from);
  void MergeFrom(const AssetStore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AssetStore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.AssetKey key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::protocol::AssetKey& key() const;
  ::protocol::AssetKey* mutable_key();
  ::protocol::AssetKey* release_key();
  void set_allocated_key(::protocol::AssetKey* key);

  // optional int64 amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // optional .protocol.AssetProperty property = 3;
  bool has_property() const;
  void clear_property();
  static const int kPropertyFieldNumber = 3;
  const ::protocol::AssetProperty& property() const;
  ::protocol::AssetProperty* mutable_property();
  ::protocol::AssetProperty* release_property();
  void set_allocated_property(::protocol::AssetProperty* property);

  // @@protoc_insertion_point(class_scope:protocol.AssetStore)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::protocol::AssetKey* key_;
  ::google::protobuf::int64 amount_;
  ::protocol::AssetProperty* property_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static AssetStore* default_instance_;
};
// -------------------------------------------------------------------

class LedgerHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.LedgerHeader) */ {
 public:
  LedgerHeader();
  virtual ~LedgerHeader();

  LedgerHeader(const LedgerHeader& from);

  inline LedgerHeader& operator=(const LedgerHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LedgerHeader& default_instance();

  void Swap(LedgerHeader* other);

  // implements Message ----------------------------------------------

  inline LedgerHeader* New() const { return New(NULL); }

  LedgerHeader* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LedgerHeader& from);
  void MergeFrom(const LedgerHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LedgerHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 seq = 1;
  void clear_seq();
  static const int kSeqFieldNumber = 1;
  ::google::protobuf::int64 seq() const;
  void set_seq(::google::protobuf::int64 value);

  // optional bytes hash = 2;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional bytes previous_hash = 3;
  void clear_previous_hash();
  static const int kPreviousHashFieldNumber = 3;
  const ::std::string& previous_hash() const;
  void set_previous_hash(const ::std::string& value);
  void set_previous_hash(const char* value);
  void set_previous_hash(const void* value, size_t size);
  ::std::string* mutable_previous_hash();
  ::std::string* release_previous_hash();
  void set_allocated_previous_hash(::std::string* previous_hash);

  // optional bytes account_tree_hash = 4;
  void clear_account_tree_hash();
  static const int kAccountTreeHashFieldNumber = 4;
  const ::std::string& account_tree_hash() const;
  void set_account_tree_hash(const ::std::string& value);
  void set_account_tree_hash(const char* value);
  void set_account_tree_hash(const void* value, size_t size);
  ::std::string* mutable_account_tree_hash();
  ::std::string* release_account_tree_hash();
  void set_allocated_account_tree_hash(::std::string* account_tree_hash);

  // optional int64 close_time = 5;
  void clear_close_time();
  static const int kCloseTimeFieldNumber = 5;
  ::google::protobuf::int64 close_time() const;
  void set_close_time(::google::protobuf::int64 value);

  // optional bytes consensus_value_hash = 6;
  void clear_consensus_value_hash();
  static const int kConsensusValueHashFieldNumber = 6;
  const ::std::string& consensus_value_hash() const;
  void set_consensus_value_hash(const ::std::string& value);
  void set_consensus_value_hash(const char* value);
  void set_consensus_value_hash(const void* value, size_t size);
  ::std::string* mutable_consensus_value_hash();
  ::std::string* release_consensus_value_hash();
  void set_allocated_consensus_value_hash(::std::string* consensus_value_hash);

  // optional int64 version = 7;
  void clear_version();
  static const int kVersionFieldNumber = 7;
  ::google::protobuf::int64 version() const;
  void set_version(::google::protobuf::int64 value);

  // optional int64 tx_count = 8;
  void clear_tx_count();
  static const int kTxCountFieldNumber = 8;
  ::google::protobuf::int64 tx_count() const;
  void set_tx_count(::google::protobuf::int64 value);

  // optional bytes validators_hash = 9;
  void clear_validators_hash();
  static const int kValidatorsHashFieldNumber = 9;
  const ::std::string& validators_hash() const;
  void set_validators_hash(const ::std::string& value);
  void set_validators_hash(const char* value);
  void set_validators_hash(const void* value, size_t size);
  ::std::string* mutable_validators_hash();
  ::std::string* release_validators_hash();
  void set_allocated_validators_hash(::std::string* validators_hash);

  // optional bytes fees_hash = 10;
  void clear_fees_hash();
  static const int kFeesHashFieldNumber = 10;
  const ::std::string& fees_hash() const;
  void set_fees_hash(const ::std::string& value);
  void set_fees_hash(const char* value);
  void set_fees_hash(const void* value, size_t size);
  ::std::string* mutable_fees_hash();
  ::std::string* release_fees_hash();
  void set_allocated_fees_hash(::std::string* fees_hash);

  // optional string reserve = 11;
  void clear_reserve();
  static const int kReserveFieldNumber = 11;
  const ::std::string& reserve() const;
  void set_reserve(const ::std::string& value);
  void set_reserve(const char* value);
  void set_reserve(const char* value, size_t size);
  ::std::string* mutable_reserve();
  ::std::string* release_reserve();
  void set_allocated_reserve(::std::string* reserve);

  // @@protoc_insertion_point(class_scope:protocol.LedgerHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 seq_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr previous_hash_;
  ::google::protobuf::internal::ArenaStringPtr account_tree_hash_;
  ::google::protobuf::int64 close_time_;
  ::google::protobuf::internal::ArenaStringPtr consensus_value_hash_;
  ::google::protobuf::int64 version_;
  ::google::protobuf::int64 tx_count_;
  ::google::protobuf::internal::ArenaStringPtr validators_hash_;
  ::google::protobuf::internal::ArenaStringPtr fees_hash_;
  ::google::protobuf::internal::ArenaStringPtr reserve_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static LedgerHeader* default_instance_;
};
// -------------------------------------------------------------------

class Ledger : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Ledger) */ {
 public:
  Ledger();
  virtual ~Ledger();

  Ledger(const Ledger& from);

  inline Ledger& operator=(const Ledger& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ledger& default_instance();

  void Swap(Ledger* other);

  // implements Message ----------------------------------------------

  inline Ledger* New() const { return New(NULL); }

  Ledger* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ledger& from);
  void MergeFrom(const Ledger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ledger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.LedgerHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::LedgerHeader& header() const;
  ::protocol::LedgerHeader* mutable_header();
  ::protocol::LedgerHeader* release_header();
  void set_allocated_header(::protocol::LedgerHeader* header);

  // repeated .protocol.TransactionEnv transaction_envs = 2;
  int transaction_envs_size() const;
  void clear_transaction_envs();
  static const int kTransactionEnvsFieldNumber = 2;
  const ::protocol::TransactionEnv& transaction_envs(int index) const;
  ::protocol::TransactionEnv* mutable_transaction_envs(int index);
  ::protocol::TransactionEnv* add_transaction_envs();
  ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv >*
      mutable_transaction_envs();
  const ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv >&
      transaction_envs() const;

  // @@protoc_insertion_point(class_scope:protocol.Ledger)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::protocol::LedgerHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv > transaction_envs_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static Ledger* default_instance_;
};
// -------------------------------------------------------------------

class OperationPayAsset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationPayAsset) */ {
 public:
  OperationPayAsset();
  virtual ~OperationPayAsset();

  OperationPayAsset(const OperationPayAsset& from);

  inline OperationPayAsset& operator=(const OperationPayAsset& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationPayAsset& default_instance();

  void Swap(OperationPayAsset* other);

  // implements Message ----------------------------------------------

  inline OperationPayAsset* New() const { return New(NULL); }

  OperationPayAsset* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationPayAsset& from);
  void MergeFrom(const OperationPayAsset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OperationPayAsset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dest_address = 1;
  void clear_dest_address();
  static const int kDestAddressFieldNumber = 1;
  const ::std::string& dest_address() const;
  void set_dest_address(const ::std::string& value);
  void set_dest_address(const char* value);
  void set_dest_address(const char* value, size_t size);
  ::std::string* mutable_dest_address();
  ::std::string* release_dest_address();
  void set_allocated_dest_address(::std::string* dest_address);

  // optional .protocol.Asset asset = 2;
  bool has_asset() const;
  void clear_asset();
  static const int kAssetFieldNumber = 2;
  const ::protocol::Asset& asset() const;
  ::protocol::Asset* mutable_asset();
  ::protocol::Asset* release_asset();
  void set_allocated_asset(::protocol::Asset* asset);

  // optional string input = 3;
  void clear_input();
  static const int kInputFieldNumber = 3;
  const ::std::string& input() const;
  void set_input(const ::std::string& value);
  void set_input(const char* value);
  void set_input(const char* value, size_t size);
  ::std::string* mutable_input();
  ::std::string* release_input();
  void set_allocated_input(::std::string* input);

  // @@protoc_insertion_point(class_scope:protocol.OperationPayAsset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr dest_address_;
  ::protocol::Asset* asset_;
  ::google::protobuf::internal::ArenaStringPtr input_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static OperationPayAsset* default_instance_;
};
// -------------------------------------------------------------------

class OperationTypeThreshold : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationTypeThreshold) */ {
 public:
  OperationTypeThreshold();
  virtual ~OperationTypeThreshold();

  OperationTypeThreshold(const OperationTypeThreshold& from);

  inline OperationTypeThreshold& operator=(const OperationTypeThreshold& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationTypeThreshold& default_instance();

  void Swap(OperationTypeThreshold* other);

  // implements Message ----------------------------------------------

  inline OperationTypeThreshold* New() const { return New(NULL); }

  OperationTypeThreshold* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationTypeThreshold& from);
  void MergeFrom(const OperationTypeThreshold& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OperationTypeThreshold* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.Operation.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::protocol::Operation_Type type() const;
  void set_type(::protocol::Operation_Type value);

  // optional int64 threshold = 2;
  void clear_threshold();
  static const int kThresholdFieldNumber = 2;
  ::google::protobuf::int64 threshold() const;
  void set_threshold(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.OperationTypeThreshold)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 threshold_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static OperationTypeThreshold* default_instance_;
};
// -------------------------------------------------------------------

class AccountPrivilege : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.AccountPrivilege) */ {
 public:
  AccountPrivilege();
  virtual ~AccountPrivilege();

  AccountPrivilege(const AccountPrivilege& from);

  inline AccountPrivilege& operator=(const AccountPrivilege& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountPrivilege& default_instance();

  void Swap(AccountPrivilege* other);

  // implements Message ----------------------------------------------

  inline AccountPrivilege* New() const { return New(NULL); }

  AccountPrivilege* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountPrivilege& from);
  void MergeFrom(const AccountPrivilege& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AccountPrivilege* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 master_weight = 1;
  void clear_master_weight();
  static const int kMasterWeightFieldNumber = 1;
  ::google::protobuf::int64 master_weight() const;
  void set_master_weight(::google::protobuf::int64 value);

  // repeated .protocol.Signer signers = 2;
  int signers_size() const;
  void clear_signers();
  static const int kSignersFieldNumber = 2;
  const ::protocol::Signer& signers(int index) const;
  ::protocol::Signer* mutable_signers(int index);
  ::protocol::Signer* add_signers();
  ::google::protobuf::RepeatedPtrField< ::protocol::Signer >*
      mutable_signers();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Signer >&
      signers() const;

  // optional .protocol.AccountThreshold thresholds = 3;
  bool has_thresholds() const;
  void clear_thresholds();
  static const int kThresholdsFieldNumber = 3;
  const ::protocol::AccountThreshold& thresholds() const;
  ::protocol::AccountThreshold* mutable_thresholds();
  ::protocol::AccountThreshold* release_thresholds();
  void set_allocated_thresholds(::protocol::AccountThreshold* thresholds);

  // @@protoc_insertion_point(class_scope:protocol.AccountPrivilege)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 master_weight_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Signer > signers_;
  ::protocol::AccountThreshold* thresholds_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static AccountPrivilege* default_instance_;
};
// -------------------------------------------------------------------

class AccountThreshold : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.AccountThreshold) */ {
 public:
  AccountThreshold();
  virtual ~AccountThreshold();

  AccountThreshold(const AccountThreshold& from);

  inline AccountThreshold& operator=(const AccountThreshold& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountThreshold& default_instance();

  void Swap(AccountThreshold* other);

  // implements Message ----------------------------------------------

  inline AccountThreshold* New() const { return New(NULL); }

  AccountThreshold* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountThreshold& from);
  void MergeFrom(const AccountThreshold& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AccountThreshold* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 tx_threshold = 1;
  void clear_tx_threshold();
  static const int kTxThresholdFieldNumber = 1;
  ::google::protobuf::int64 tx_threshold() const;
  void set_tx_threshold(::google::protobuf::int64 value);

  // repeated .protocol.OperationTypeThreshold type_thresholds = 2;
  int type_thresholds_size() const;
  void clear_type_thresholds();
  static const int kTypeThresholdsFieldNumber = 2;
  const ::protocol::OperationTypeThreshold& type_thresholds(int index) const;
  ::protocol::OperationTypeThreshold* mutable_type_thresholds(int index);
  ::protocol::OperationTypeThreshold* add_type_thresholds();
  ::google::protobuf::RepeatedPtrField< ::protocol::OperationTypeThreshold >*
      mutable_type_thresholds();
  const ::google::protobuf::RepeatedPtrField< ::protocol::OperationTypeThreshold >&
      type_thresholds() const;

  // @@protoc_insertion_point(class_scope:protocol.AccountThreshold)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 tx_threshold_;
  ::google::protobuf::RepeatedPtrField< ::protocol::OperationTypeThreshold > type_thresholds_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static AccountThreshold* default_instance_;
};
// -------------------------------------------------------------------

class OperationIssueAsset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationIssueAsset) */ {
 public:
  OperationIssueAsset();
  virtual ~OperationIssueAsset();

  OperationIssueAsset(const OperationIssueAsset& from);

  inline OperationIssueAsset& operator=(const OperationIssueAsset& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationIssueAsset& default_instance();

  void Swap(OperationIssueAsset* other);

  // implements Message ----------------------------------------------

  inline OperationIssueAsset* New() const { return New(NULL); }

  OperationIssueAsset* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationIssueAsset& from);
  void MergeFrom(const OperationIssueAsset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OperationIssueAsset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // optional int64 amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.OperationIssueAsset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  ::google::protobuf::int64 amount_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static OperationIssueAsset* default_instance_;
};
// -------------------------------------------------------------------

class OperationPayCoin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationPayCoin) */ {
 public:
  OperationPayCoin();
  virtual ~OperationPayCoin();

  OperationPayCoin(const OperationPayCoin& from);

  inline OperationPayCoin& operator=(const OperationPayCoin& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationPayCoin& default_instance();

  void Swap(OperationPayCoin* other);

  // implements Message ----------------------------------------------

  inline OperationPayCoin* New() const { return New(NULL); }

  OperationPayCoin* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationPayCoin& from);
  void MergeFrom(const OperationPayCoin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OperationPayCoin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dest_address = 1;
  void clear_dest_address();
  static const int kDestAddressFieldNumber = 1;
  const ::std::string& dest_address() const;
  void set_dest_address(const ::std::string& value);
  void set_dest_address(const char* value);
  void set_dest_address(const char* value, size_t size);
  ::std::string* mutable_dest_address();
  ::std::string* release_dest_address();
  void set_allocated_dest_address(::std::string* dest_address);

  // optional int64 amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // optional string input = 3;
  void clear_input();
  static const int kInputFieldNumber = 3;
  const ::std::string& input() const;
  void set_input(const ::std::string& value);
  void set_input(const char* value);
  void set_input(const char* value, size_t size);
  ::std::string* mutable_input();
  ::std::string* release_input();
  void set_allocated_input(::std::string* input);

  // @@protoc_insertion_point(class_scope:protocol.OperationPayCoin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr dest_address_;
  ::google::protobuf::int64 amount_;
  ::google::protobuf::internal::ArenaStringPtr input_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static OperationPayCoin* default_instance_;
};
// -------------------------------------------------------------------

class OperationSetSignerWeight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationSetSignerWeight) */ {
 public:
  OperationSetSignerWeight();
  virtual ~OperationSetSignerWeight();

  OperationSetSignerWeight(const OperationSetSignerWeight& from);

  inline OperationSetSignerWeight& operator=(const OperationSetSignerWeight& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationSetSignerWeight& default_instance();

  void Swap(OperationSetSignerWeight* other);

  // implements Message ----------------------------------------------

  inline OperationSetSignerWeight* New() const { return New(NULL); }

  OperationSetSignerWeight* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationSetSignerWeight& from);
  void MergeFrom(const OperationSetSignerWeight& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OperationSetSignerWeight* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 master_weight = 1;
  void clear_master_weight();
  static const int kMasterWeightFieldNumber = 1;
  ::google::protobuf::int64 master_weight() const;
  void set_master_weight(::google::protobuf::int64 value);

  // repeated .protocol.Signer signers = 2;
  int signers_size() const;
  void clear_signers();
  static const int kSignersFieldNumber = 2;
  const ::protocol::Signer& signers(int index) const;
  ::protocol::Signer* mutable_signers(int index);
  ::protocol::Signer* add_signers();
  ::google::protobuf::RepeatedPtrField< ::protocol::Signer >*
      mutable_signers();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Signer >&
      signers() const;

  // @@protoc_insertion_point(class_scope:protocol.OperationSetSignerWeight)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 master_weight_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Signer > signers_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static OperationSetSignerWeight* default_instance_;
};
// -------------------------------------------------------------------

class OperationLog : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationLog) */ {
 public:
  OperationLog();
  virtual ~OperationLog();

  OperationLog(const OperationLog& from);

  inline OperationLog& operator=(const OperationLog& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationLog& default_instance();

  void Swap(OperationLog* other);

  // implements Message ----------------------------------------------

  inline OperationLog* New() const { return New(NULL); }

  OperationLog* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationLog& from);
  void MergeFrom(const OperationLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OperationLog* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string topic = 1;
  void clear_topic();
  static const int kTopicFieldNumber = 1;
  const ::std::string& topic() const;
  void set_topic(const ::std::string& value);
  void set_topic(const char* value);
  void set_topic(const char* value, size_t size);
  ::std::string* mutable_topic();
  ::std::string* release_topic();
  void set_allocated_topic(::std::string* topic);

  // repeated string datas = 2;
  int datas_size() const;
  void clear_datas();
  static const int kDatasFieldNumber = 2;
  const ::std::string& datas(int index) const;
  ::std::string* mutable_datas(int index);
  void set_datas(int index, const ::std::string& value);
  void set_datas(int index, const char* value);
  void set_datas(int index, const char* value, size_t size);
  ::std::string* add_datas();
  void add_datas(const ::std::string& value);
  void add_datas(const char* value);
  void add_datas(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& datas() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_datas();

  // @@protoc_insertion_point(class_scope:protocol.OperationLog)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr topic_;
  ::google::protobuf::RepeatedPtrField< ::std::string> datas_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static OperationLog* default_instance_;
};
// -------------------------------------------------------------------

class OperationSetPrivilege : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationSetPrivilege) */ {
 public:
  OperationSetPrivilege();
  virtual ~OperationSetPrivilege();

  OperationSetPrivilege(const OperationSetPrivilege& from);

  inline OperationSetPrivilege& operator=(const OperationSetPrivilege& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationSetPrivilege& default_instance();

  void Swap(OperationSetPrivilege* other);

  // implements Message ----------------------------------------------

  inline OperationSetPrivilege* New() const { return New(NULL); }

  OperationSetPrivilege* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationSetPrivilege& from);
  void MergeFrom(const OperationSetPrivilege& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OperationSetPrivilege* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string master_weight = 1;
  void clear_master_weight();
  static const int kMasterWeightFieldNumber = 1;
  const ::std::string& master_weight() const;
  void set_master_weight(const ::std::string& value);
  void set_master_weight(const char* value);
  void set_master_weight(const char* value, size_t size);
  ::std::string* mutable_master_weight();
  ::std::string* release_master_weight();
  void set_allocated_master_weight(::std::string* master_weight);

  // repeated .protocol.Signer signers = 2;
  int signers_size() const;
  void clear_signers();
  static const int kSignersFieldNumber = 2;
  const ::protocol::Signer& signers(int index) const;
  ::protocol::Signer* mutable_signers(int index);
  ::protocol::Signer* add_signers();
  ::google::protobuf::RepeatedPtrField< ::protocol::Signer >*
      mutable_signers();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Signer >&
      signers() const;

  // optional string tx_threshold = 3;
  void clear_tx_threshold();
  static const int kTxThresholdFieldNumber = 3;
  const ::std::string& tx_threshold() const;
  void set_tx_threshold(const ::std::string& value);
  void set_tx_threshold(const char* value);
  void set_tx_threshold(const char* value, size_t size);
  ::std::string* mutable_tx_threshold();
  ::std::string* release_tx_threshold();
  void set_allocated_tx_threshold(::std::string* tx_threshold);

  // repeated .protocol.OperationTypeThreshold type_thresholds = 4;
  int type_thresholds_size() const;
  void clear_type_thresholds();
  static const int kTypeThresholdsFieldNumber = 4;
  const ::protocol::OperationTypeThreshold& type_thresholds(int index) const;
  ::protocol::OperationTypeThreshold* mutable_type_thresholds(int index);
  ::protocol::OperationTypeThreshold* add_type_thresholds();
  ::google::protobuf::RepeatedPtrField< ::protocol::OperationTypeThreshold >*
      mutable_type_thresholds();
  const ::google::protobuf::RepeatedPtrField< ::protocol::OperationTypeThreshold >&
      type_thresholds() const;

  // @@protoc_insertion_point(class_scope:protocol.OperationSetPrivilege)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr master_weight_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Signer > signers_;
  ::google::protobuf::internal::ArenaStringPtr tx_threshold_;
  ::google::protobuf::RepeatedPtrField< ::protocol::OperationTypeThreshold > type_thresholds_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static OperationSetPrivilege* default_instance_;
};
// -------------------------------------------------------------------

class Operation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Operation) */ {
 public:
  Operation();
  virtual ~Operation();

  Operation(const Operation& from);

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Operation& default_instance();

  void Swap(Operation* other);

  // implements Message ----------------------------------------------

  inline Operation* New() const { return New(NULL); }

  Operation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Operation& from);
  void MergeFrom(const Operation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Operation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Operation_Type Type;
  static const Type UNKNOWN =
    Operation_Type_UNKNOWN;
  static const Type CREATE_ACCOUNT =
    Operation_Type_CREATE_ACCOUNT;
  static const Type ISSUE_ASSET =
    Operation_Type_ISSUE_ASSET;
  static const Type PAY_ASSET =
    Operation_Type_PAY_ASSET;
  static const Type SET_METADATA =
    Operation_Type_SET_METADATA;
  static const Type SET_SIGNER_WEIGHT =
    Operation_Type_SET_SIGNER_WEIGHT;
  static const Type SET_THRESHOLD =
    Operation_Type_SET_THRESHOLD;
  static const Type PAY_COIN =
    Operation_Type_PAY_COIN;
  static const Type LOG =
    Operation_Type_LOG;
  static const Type SET_PRIVILEGE =
    Operation_Type_SET_PRIVILEGE;
  static inline bool Type_IsValid(int value) {
    return Operation_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Operation_Type_Type_MIN;
  static const Type Type_MAX =
    Operation_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Operation_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Operation_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Operation_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Operation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .protocol.Operation.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::protocol::Operation_Type type() const;
  void set_type(::protocol::Operation_Type value);

  // optional string source_address = 2;
  void clear_source_address();
  static const int kSourceAddressFieldNumber = 2;
  const ::std::string& source_address() const;
  void set_source_address(const ::std::string& value);
  void set_source_address(const char* value);
  void set_source_address(const char* value, size_t size);
  ::std::string* mutable_source_address();
  ::std::string* release_source_address();
  void set_allocated_source_address(::std::string* source_address);

  // optional bytes metadata = 3;
  void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  void set_metadata(const char* value);
  void set_metadata(const void* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // optional .protocol.OperationCreateAccount create_account = 4;
  bool has_create_account() const;
  void clear_create_account();
  static const int kCreateAccountFieldNumber = 4;
  const ::protocol::OperationCreateAccount& create_account() const;
  ::protocol::OperationCreateAccount* mutable_create_account();
  ::protocol::OperationCreateAccount* release_create_account();
  void set_allocated_create_account(::protocol::OperationCreateAccount* create_account);

  // optional .protocol.OperationIssueAsset issue_asset = 5;
  bool has_issue_asset() const;
  void clear_issue_asset();
  static const int kIssueAssetFieldNumber = 5;
  const ::protocol::OperationIssueAsset& issue_asset() const;
  ::protocol::OperationIssueAsset* mutable_issue_asset();
  ::protocol::OperationIssueAsset* release_issue_asset();
  void set_allocated_issue_asset(::protocol::OperationIssueAsset* issue_asset);

  // optional .protocol.OperationPayAsset pay_asset = 6;
  bool has_pay_asset() const;
  void clear_pay_asset();
  static const int kPayAssetFieldNumber = 6;
  const ::protocol::OperationPayAsset& pay_asset() const;
  ::protocol::OperationPayAsset* mutable_pay_asset();
  ::protocol::OperationPayAsset* release_pay_asset();
  void set_allocated_pay_asset(::protocol::OperationPayAsset* pay_asset);

  // optional .protocol.OperationSetMetadata set_metadata = 7;
  bool has_set_metadata() const;
  void clear_set_metadata();
  static const int kSetMetadataFieldNumber = 7;
  const ::protocol::OperationSetMetadata& set_metadata() const;
  ::protocol::OperationSetMetadata* mutable_set_metadata();
  ::protocol::OperationSetMetadata* release_set_metadata();
  void set_allocated_set_metadata(::protocol::OperationSetMetadata* set_metadata);

  // optional .protocol.OperationSetSignerWeight set_signer_weight = 8;
  bool has_set_signer_weight() const;
  void clear_set_signer_weight();
  static const int kSetSignerWeightFieldNumber = 8;
  const ::protocol::OperationSetSignerWeight& set_signer_weight() const;
  ::protocol::OperationSetSignerWeight* mutable_set_signer_weight();
  ::protocol::OperationSetSignerWeight* release_set_signer_weight();
  void set_allocated_set_signer_weight(::protocol::OperationSetSignerWeight* set_signer_weight);

  // optional .protocol.OperationSetThreshold set_threshold = 9;
  bool has_set_threshold() const;
  void clear_set_threshold();
  static const int kSetThresholdFieldNumber = 9;
  const ::protocol::OperationSetThreshold& set_threshold() const;
  ::protocol::OperationSetThreshold* mutable_set_threshold();
  ::protocol::OperationSetThreshold* release_set_threshold();
  void set_allocated_set_threshold(::protocol::OperationSetThreshold* set_threshold);

  // optional .protocol.OperationPayCoin pay_coin = 10;
  bool has_pay_coin() const;
  void clear_pay_coin();
  static const int kPayCoinFieldNumber = 10;
  const ::protocol::OperationPayCoin& pay_coin() const;
  ::protocol::OperationPayCoin* mutable_pay_coin();
  ::protocol::OperationPayCoin* release_pay_coin();
  void set_allocated_pay_coin(::protocol::OperationPayCoin* pay_coin);

  // optional .protocol.OperationLog log = 11;
  bool has_log() const;
  void clear_log();
  static const int kLogFieldNumber = 11;
  const ::protocol::OperationLog& log() const;
  ::protocol::OperationLog* mutable_log();
  ::protocol::OperationLog* release_log();
  void set_allocated_log(::protocol::OperationLog* log);

  // optional .protocol.OperationSetPrivilege set_privilege = 12;
  bool has_set_privilege() const;
  void clear_set_privilege();
  static const int kSetPrivilegeFieldNumber = 12;
  const ::protocol::OperationSetPrivilege& set_privilege() const;
  ::protocol::OperationSetPrivilege* mutable_set_privilege();
  ::protocol::OperationSetPrivilege* release_set_privilege();
  void set_allocated_set_privilege(::protocol::OperationSetPrivilege* set_privilege);

  // @@protoc_insertion_point(class_scope:protocol.Operation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr source_address_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::protocol::OperationCreateAccount* create_account_;
  ::protocol::OperationIssueAsset* issue_asset_;
  ::protocol::OperationPayAsset* pay_asset_;
  ::protocol::OperationSetMetadata* set_metadata_;
  ::protocol::OperationSetSignerWeight* set_signer_weight_;
  ::protocol::OperationSetThreshold* set_threshold_;
  ::protocol::OperationPayCoin* pay_coin_;
  ::protocol::OperationLog* log_;
  ::protocol::OperationSetPrivilege* set_privilege_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static Operation* default_instance_;
};
// -------------------------------------------------------------------

class OperationSetThreshold : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationSetThreshold) */ {
 public:
  OperationSetThreshold();
  virtual ~OperationSetThreshold();

  OperationSetThreshold(const OperationSetThreshold& from);

  inline OperationSetThreshold& operator=(const OperationSetThreshold& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationSetThreshold& default_instance();

  void Swap(OperationSetThreshold* other);

  // implements Message ----------------------------------------------

  inline OperationSetThreshold* New() const { return New(NULL); }

  OperationSetThreshold* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationSetThreshold& from);
  void MergeFrom(const OperationSetThreshold& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OperationSetThreshold* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 tx_threshold = 1;
  void clear_tx_threshold();
  static const int kTxThresholdFieldNumber = 1;
  ::google::protobuf::int64 tx_threshold() const;
  void set_tx_threshold(::google::protobuf::int64 value);

  // repeated .protocol.OperationTypeThreshold type_thresholds = 2;
  int type_thresholds_size() const;
  void clear_type_thresholds();
  static const int kTypeThresholdsFieldNumber = 2;
  const ::protocol::OperationTypeThreshold& type_thresholds(int index) const;
  ::protocol::OperationTypeThreshold* mutable_type_thresholds(int index);
  ::protocol::OperationTypeThreshold* add_type_thresholds();
  ::google::protobuf::RepeatedPtrField< ::protocol::OperationTypeThreshold >*
      mutable_type_thresholds();
  const ::google::protobuf::RepeatedPtrField< ::protocol::OperationTypeThreshold >&
      type_thresholds() const;

  // @@protoc_insertion_point(class_scope:protocol.OperationSetThreshold)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 tx_threshold_;
  ::google::protobuf::RepeatedPtrField< ::protocol::OperationTypeThreshold > type_thresholds_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static OperationSetThreshold* default_instance_;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction) */ {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();

  void Swap(Transaction* other);

  // implements Message ----------------------------------------------

  inline Transaction* New() const { return New(NULL); }

  Transaction* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Transaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Transaction_Limit Limit;
  static const Limit UNKNOWN =
    Transaction_Limit_UNKNOWN;
  static const Limit OPERATIONS =
    Transaction_Limit_OPERATIONS;
  static inline bool Limit_IsValid(int value) {
    return Transaction_Limit_IsValid(value);
  }
  static const Limit Limit_MIN =
    Transaction_Limit_Limit_MIN;
  static const Limit Limit_MAX =
    Transaction_Limit_Limit_MAX;
  static const int Limit_ARRAYSIZE =
    Transaction_Limit_Limit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Limit_descriptor() {
    return Transaction_Limit_descriptor();
  }
  static inline const ::std::string& Limit_Name(Limit value) {
    return Transaction_Limit_Name(value);
  }
  static inline bool Limit_Parse(const ::std::string& name,
      Limit* value) {
    return Transaction_Limit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string source_address = 1;
  void clear_source_address();
  static const int kSourceAddressFieldNumber = 1;
  const ::std::string& source_address() const;
  void set_source_address(const ::std::string& value);
  void set_source_address(const char* value);
  void set_source_address(const char* value, size_t size);
  ::std::string* mutable_source_address();
  ::std::string* release_source_address();
  void set_allocated_source_address(::std::string* source_address);

  // optional int64 nonce = 2;
  void clear_nonce();
  static const int kNonceFieldNumber = 2;
  ::google::protobuf::int64 nonce() const;
  void set_nonce(::google::protobuf::int64 value);

  // optional int64 fee_limit = 3;
  void clear_fee_limit();
  static const int kFeeLimitFieldNumber = 3;
  ::google::protobuf::int64 fee_limit() const;
  void set_fee_limit(::google::protobuf::int64 value);

  // optional int64 gas_price = 4;
  void clear_gas_price();
  static const int kGasPriceFieldNumber = 4;
  ::google::protobuf::int64 gas_price() const;
  void set_gas_price(::google::protobuf::int64 value);

  // optional int64 ceil_ledger_seq = 5;
  void clear_ceil_ledger_seq();
  static const int kCeilLedgerSeqFieldNumber = 5;
  ::google::protobuf::int64 ceil_ledger_seq() const;
  void set_ceil_ledger_seq(::google::protobuf::int64 value);

  // optional bytes metadata = 6;
  void clear_metadata();
  static const int kMetadataFieldNumber = 6;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  void set_metadata(const char* value);
  void set_metadata(const void* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // repeated .protocol.Operation operations = 7;
  int operations_size() const;
  void clear_operations();
  static const int kOperationsFieldNumber = 7;
  const ::protocol::Operation& operations(int index) const;
  ::protocol::Operation* mutable_operations(int index);
  ::protocol::Operation* add_operations();
  ::google::protobuf::RepeatedPtrField< ::protocol::Operation >*
      mutable_operations();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Operation >&
      operations() const;

  // @@protoc_insertion_point(class_scope:protocol.Transaction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr source_address_;
  ::google::protobuf::int64 nonce_;
  ::google::protobuf::int64 fee_limit_;
  ::google::protobuf::int64 gas_price_;
  ::google::protobuf::int64 ceil_ledger_seq_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Operation > operations_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static Transaction* default_instance_;
};
// -------------------------------------------------------------------

class Signer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Signer) */ {
 public:
  Signer();
  virtual ~Signer();

  Signer(const Signer& from);

  inline Signer& operator=(const Signer& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Signer& default_instance();

  void Swap(Signer* other);

  // implements Message ----------------------------------------------

  inline Signer* New() const { return New(NULL); }

  Signer* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Signer& from);
  void MergeFrom(const Signer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Signer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Signer_Limit Limit;
  static const Limit SIGNER_NONE =
    Signer_Limit_SIGNER_NONE;
  static const Limit SIGNER =
    Signer_Limit_SIGNER;
  static inline bool Limit_IsValid(int value) {
    return Signer_Limit_IsValid(value);
  }
  static const Limit Limit_MIN =
    Signer_Limit_Limit_MIN;
  static const Limit Limit_MAX =
    Signer_Limit_Limit_MAX;
  static const int Limit_ARRAYSIZE =
    Signer_Limit_Limit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Limit_descriptor() {
    return Signer_Limit_descriptor();
  }
  static inline const ::std::string& Limit_Name(Limit value) {
    return Signer_Limit_Name(value);
  }
  static inline bool Limit_Parse(const ::std::string& name,
      Limit* value) {
    return Signer_Limit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional int64 weight = 2;
  void clear_weight();
  static const int kWeightFieldNumber = 2;
  ::google::protobuf::int64 weight() const;
  void set_weight(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.Signer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::int64 weight_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static Signer* default_instance_;
};
// -------------------------------------------------------------------

class Trigger_OperationTrigger : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Trigger.OperationTrigger) */ {
 public:
  Trigger_OperationTrigger();
  virtual ~Trigger_OperationTrigger();

  Trigger_OperationTrigger(const Trigger_OperationTrigger& from);

  inline Trigger_OperationTrigger& operator=(const Trigger_OperationTrigger& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Trigger_OperationTrigger& default_instance();

  void Swap(Trigger_OperationTrigger* other);

  // implements Message ----------------------------------------------

  inline Trigger_OperationTrigger* New() const { return New(NULL); }

  Trigger_OperationTrigger* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Trigger_OperationTrigger& from);
  void MergeFrom(const Trigger_OperationTrigger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Trigger_OperationTrigger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional int64 index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::int64 index() const;
  void set_index(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.Trigger.OperationTrigger)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::int64 index_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static Trigger_OperationTrigger* default_instance_;
};
// -------------------------------------------------------------------

class Trigger : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Trigger) */ {
 public:
  Trigger();
  virtual ~Trigger();

  Trigger(const Trigger& from);

  inline Trigger& operator=(const Trigger& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Trigger& default_instance();

  void Swap(Trigger* other);

  // implements Message ----------------------------------------------

  inline Trigger* New() const { return New(NULL); }

  Trigger* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Trigger& from);
  void MergeFrom(const Trigger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Trigger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Trigger_OperationTrigger OperationTrigger;

  typedef Trigger_TransactionType TransactionType;
  static const TransactionType NORMAL_TRANSACTION =
    Trigger_TransactionType_NORMAL_TRANSACTION;
  static const TransactionType CONTRACT_TRANSACTION =
    Trigger_TransactionType_CONTRACT_TRANSACTION;
  static inline bool TransactionType_IsValid(int value) {
    return Trigger_TransactionType_IsValid(value);
  }
  static const TransactionType TransactionType_MIN =
    Trigger_TransactionType_TransactionType_MIN;
  static const TransactionType TransactionType_MAX =
    Trigger_TransactionType_TransactionType_MAX;
  static const int TransactionType_ARRAYSIZE =
    Trigger_TransactionType_TransactionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TransactionType_descriptor() {
    return Trigger_TransactionType_descriptor();
  }
  static inline const ::std::string& TransactionType_Name(TransactionType value) {
    return Trigger_TransactionType_Name(value);
  }
  static inline bool TransactionType_Parse(const ::std::string& name,
      TransactionType* value) {
    return Trigger_TransactionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .protocol.Trigger.TransactionType transaction_type = 1;
  void clear_transaction_type();
  static const int kTransactionTypeFieldNumber = 1;
  ::protocol::Trigger_TransactionType transaction_type() const;
  void set_transaction_type(::protocol::Trigger_TransactionType value);

  // optional int64 ledger_seq = 2;
  void clear_ledger_seq();
  static const int kLedgerSeqFieldNumber = 2;
  ::google::protobuf::int64 ledger_seq() const;
  void set_ledger_seq(::google::protobuf::int64 value);

  // optional .protocol.Trigger.OperationTrigger transaction = 3;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 3;
  const ::protocol::Trigger_OperationTrigger& transaction() const;
  ::protocol::Trigger_OperationTrigger* mutable_transaction();
  ::protocol::Trigger_OperationTrigger* release_transaction();
  void set_allocated_transaction(::protocol::Trigger_OperationTrigger* transaction);

  // @@protoc_insertion_point(class_scope:protocol.Trigger)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 ledger_seq_;
  ::protocol::Trigger_OperationTrigger* transaction_;
  int transaction_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static Trigger* default_instance_;
};
// -------------------------------------------------------------------

class TransactionEnv : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionEnv) */ {
 public:
  TransactionEnv();
  virtual ~TransactionEnv();

  TransactionEnv(const TransactionEnv& from);

  inline TransactionEnv& operator=(const TransactionEnv& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionEnv& default_instance();

  void Swap(TransactionEnv* other);

  // implements Message ----------------------------------------------

  inline TransactionEnv* New() const { return New(NULL); }

  TransactionEnv* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransactionEnv& from);
  void MergeFrom(const TransactionEnv& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TransactionEnv* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.Transaction transaction = 1;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 1;
  const ::protocol::Transaction& transaction() const;
  ::protocol::Transaction* mutable_transaction();
  ::protocol::Transaction* release_transaction();
  void set_allocated_transaction(::protocol::Transaction* transaction);

  // repeated .protocol.Signature signatures = 2;
  int signatures_size() const;
  void clear_signatures();
  static const int kSignaturesFieldNumber = 2;
  const ::protocol::Signature& signatures(int index) const;
  ::protocol::Signature* mutable_signatures(int index);
  ::protocol::Signature* add_signatures();
  ::google::protobuf::RepeatedPtrField< ::protocol::Signature >*
      mutable_signatures();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Signature >&
      signatures() const;

  // optional .protocol.Trigger trigger = 3;
  bool has_trigger() const;
  void clear_trigger();
  static const int kTriggerFieldNumber = 3;
  const ::protocol::Trigger& trigger() const;
  ::protocol::Trigger* mutable_trigger();
  ::protocol::Trigger* release_trigger();
  void set_allocated_trigger(::protocol::Trigger* trigger);

  // @@protoc_insertion_point(class_scope:protocol.TransactionEnv)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::protocol::Transaction* transaction_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Signature > signatures_;
  ::protocol::Trigger* trigger_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static TransactionEnv* default_instance_;
};
// -------------------------------------------------------------------

class TransactionEnvStore : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionEnvStore) */ {
 public:
  TransactionEnvStore();
  virtual ~TransactionEnvStore();

  TransactionEnvStore(const TransactionEnvStore& from);

  inline TransactionEnvStore& operator=(const TransactionEnvStore& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionEnvStore& default_instance();

  void Swap(TransactionEnvStore* other);

  // implements Message ----------------------------------------------

  inline TransactionEnvStore* New() const { return New(NULL); }

  TransactionEnvStore* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransactionEnvStore& from);
  void MergeFrom(const TransactionEnvStore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TransactionEnvStore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.TransactionEnv transaction_env = 1;
  bool has_transaction_env() const;
  void clear_transaction_env();
  static const int kTransactionEnvFieldNumber = 1;
  const ::protocol::TransactionEnv& transaction_env() const;
  ::protocol::TransactionEnv* mutable_transaction_env();
  ::protocol::TransactionEnv* release_transaction_env();
  void set_allocated_transaction_env(::protocol::TransactionEnv* transaction_env);

  // optional int32 error_code = 2;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  ::google::protobuf::int32 error_code() const;
  void set_error_code(::google::protobuf::int32 value);

  // optional string error_desc = 3;
  void clear_error_desc();
  static const int kErrorDescFieldNumber = 3;
  const ::std::string& error_desc() const;
  void set_error_desc(const ::std::string& value);
  void set_error_desc(const char* value);
  void set_error_desc(const char* value, size_t size);
  ::std::string* mutable_error_desc();
  ::std::string* release_error_desc();
  void set_allocated_error_desc(::std::string* error_desc);

  // optional int64 ledger_seq = 4;
  void clear_ledger_seq();
  static const int kLedgerSeqFieldNumber = 4;
  ::google::protobuf::int64 ledger_seq() const;
  void set_ledger_seq(::google::protobuf::int64 value);

  // optional int64 close_time = 5;
  void clear_close_time();
  static const int kCloseTimeFieldNumber = 5;
  ::google::protobuf::int64 close_time() const;
  void set_close_time(::google::protobuf::int64 value);

  // optional bytes hash = 6;
  void clear_hash();
  static const int kHashFieldNumber = 6;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional int64 actual_fee = 7;
  void clear_actual_fee();
  static const int kActualFeeFieldNumber = 7;
  ::google::protobuf::int64 actual_fee() const;
  void set_actual_fee(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.TransactionEnvStore)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::protocol::TransactionEnv* transaction_env_;
  ::google::protobuf::internal::ArenaStringPtr error_desc_;
  ::google::protobuf::int64 ledger_seq_;
  ::google::protobuf::int64 close_time_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::int64 actual_fee_;
  ::google::protobuf::int32 error_code_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static TransactionEnvStore* default_instance_;
};
// -------------------------------------------------------------------

class TransactionEnvSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionEnvSet) */ {
 public:
  TransactionEnvSet();
  virtual ~TransactionEnvSet();

  TransactionEnvSet(const TransactionEnvSet& from);

  inline TransactionEnvSet& operator=(const TransactionEnvSet& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionEnvSet& default_instance();

  void Swap(TransactionEnvSet* other);

  // implements Message ----------------------------------------------

  inline TransactionEnvSet* New() const { return New(NULL); }

  TransactionEnvSet* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransactionEnvSet& from);
  void MergeFrom(const TransactionEnvSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TransactionEnvSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.TransactionEnv txs = 2;
  int txs_size() const;
  void clear_txs();
  static const int kTxsFieldNumber = 2;
  const ::protocol::TransactionEnv& txs(int index) const;
  ::protocol::TransactionEnv* mutable_txs(int index);
  ::protocol::TransactionEnv* add_txs();
  ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv >*
      mutable_txs();
  const ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv >&
      txs() const;

  // @@protoc_insertion_point(class_scope:protocol.TransactionEnvSet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv > txs_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static TransactionEnvSet* default_instance_;
};
// -------------------------------------------------------------------

class ConsensusValueValidation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ConsensusValueValidation) */ {
 public:
  ConsensusValueValidation();
  virtual ~ConsensusValueValidation();

  ConsensusValueValidation(const ConsensusValueValidation& from);

  inline ConsensusValueValidation& operator=(const ConsensusValueValidation& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConsensusValueValidation& default_instance();

  void Swap(ConsensusValueValidation* other);

  // implements Message ----------------------------------------------

  inline ConsensusValueValidation* New() const { return New(NULL); }

  ConsensusValueValidation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConsensusValueValidation& from);
  void MergeFrom(const ConsensusValueValidation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConsensusValueValidation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 expire_tx_ids = 1;
  int expire_tx_ids_size() const;
  void clear_expire_tx_ids();
  static const int kExpireTxIdsFieldNumber = 1;
  ::google::protobuf::int32 expire_tx_ids(int index) const;
  void set_expire_tx_ids(int index, ::google::protobuf::int32 value);
  void add_expire_tx_ids(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      expire_tx_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_expire_tx_ids();

  // repeated int32 error_tx_ids = 2;
  int error_tx_ids_size() const;
  void clear_error_tx_ids();
  static const int kErrorTxIdsFieldNumber = 2;
  ::google::protobuf::int32 error_tx_ids(int index) const;
  void set_error_tx_ids(int index, ::google::protobuf::int32 value);
  void add_error_tx_ids(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      error_tx_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_error_tx_ids();

  // @@protoc_insertion_point(class_scope:protocol.ConsensusValueValidation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > expire_tx_ids_;
  mutable int _expire_tx_ids_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > error_tx_ids_;
  mutable int _error_tx_ids_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static ConsensusValueValidation* default_instance_;
};
// -------------------------------------------------------------------

class ConsensusValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ConsensusValue) */ {
 public:
  ConsensusValue();
  virtual ~ConsensusValue();

  ConsensusValue(const ConsensusValue& from);

  inline ConsensusValue& operator=(const ConsensusValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConsensusValue& default_instance();

  void Swap(ConsensusValue* other);

  // implements Message ----------------------------------------------

  inline ConsensusValue* New() const { return New(NULL); }

  ConsensusValue* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConsensusValue& from);
  void MergeFrom(const ConsensusValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConsensusValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.TransactionEnvSet txset = 1;
  bool has_txset() const;
  void clear_txset();
  static const int kTxsetFieldNumber = 1;
  const ::protocol::TransactionEnvSet& txset() const;
  ::protocol::TransactionEnvSet* mutable_txset();
  ::protocol::TransactionEnvSet* release_txset();
  void set_allocated_txset(::protocol::TransactionEnvSet* txset);

  // optional int64 close_time = 2;
  void clear_close_time();
  static const int kCloseTimeFieldNumber = 2;
  ::google::protobuf::int64 close_time() const;
  void set_close_time(::google::protobuf::int64 value);

  // optional bytes previous_proof = 3;
  void clear_previous_proof();
  static const int kPreviousProofFieldNumber = 3;
  const ::std::string& previous_proof() const;
  void set_previous_proof(const ::std::string& value);
  void set_previous_proof(const char* value);
  void set_previous_proof(const void* value, size_t size);
  ::std::string* mutable_previous_proof();
  ::std::string* release_previous_proof();
  void set_allocated_previous_proof(::std::string* previous_proof);

  // optional int64 ledger_seq = 4;
  void clear_ledger_seq();
  static const int kLedgerSeqFieldNumber = 4;
  ::google::protobuf::int64 ledger_seq() const;
  void set_ledger_seq(::google::protobuf::int64 value);

  // optional bytes previous_ledger_hash = 5;
  void clear_previous_ledger_hash();
  static const int kPreviousLedgerHashFieldNumber = 5;
  const ::std::string& previous_ledger_hash() const;
  void set_previous_ledger_hash(const ::std::string& value);
  void set_previous_ledger_hash(const char* value);
  void set_previous_ledger_hash(const void* value, size_t size);
  ::std::string* mutable_previous_ledger_hash();
  ::std::string* release_previous_ledger_hash();
  void set_allocated_previous_ledger_hash(::std::string* previous_ledger_hash);

  // optional .protocol.LedgerUpgrade ledger_upgrade = 6;
  bool has_ledger_upgrade() const;
  void clear_ledger_upgrade();
  static const int kLedgerUpgradeFieldNumber = 6;
  const ::protocol::LedgerUpgrade& ledger_upgrade() const;
  ::protocol::LedgerUpgrade* mutable_ledger_upgrade();
  ::protocol::LedgerUpgrade* release_ledger_upgrade();
  void set_allocated_ledger_upgrade(::protocol::LedgerUpgrade* ledger_upgrade);

  // optional .protocol.ConsensusValueValidation validation = 7;
  bool has_validation() const;
  void clear_validation();
  static const int kValidationFieldNumber = 7;
  const ::protocol::ConsensusValueValidation& validation() const;
  ::protocol::ConsensusValueValidation* mutable_validation();
  ::protocol::ConsensusValueValidation* release_validation();
  void set_allocated_validation(::protocol::ConsensusValueValidation* validation);

  // @@protoc_insertion_point(class_scope:protocol.ConsensusValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::protocol::TransactionEnvSet* txset_;
  ::google::protobuf::int64 close_time_;
  ::google::protobuf::internal::ArenaStringPtr previous_proof_;
  ::google::protobuf::int64 ledger_seq_;
  ::google::protobuf::internal::ArenaStringPtr previous_ledger_hash_;
  ::protocol::LedgerUpgrade* ledger_upgrade_;
  ::protocol::ConsensusValueValidation* validation_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static ConsensusValue* default_instance_;
};
// -------------------------------------------------------------------

class Contract : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Contract) */ {
 public:
  Contract();
  virtual ~Contract();

  Contract(const Contract& from);

  inline Contract& operator=(const Contract& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Contract& default_instance();

  void Swap(Contract* other);

  // implements Message ----------------------------------------------

  inline Contract* New() const { return New(NULL); }

  Contract* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Contract& from);
  void MergeFrom(const Contract& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Contract* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Contract_ContractType ContractType;
  static const ContractType JAVASCRIPT =
    Contract_ContractType_JAVASCRIPT;
  static inline bool ContractType_IsValid(int value) {
    return Contract_ContractType_IsValid(value);
  }
  static const ContractType ContractType_MIN =
    Contract_ContractType_ContractType_MIN;
  static const ContractType ContractType_MAX =
    Contract_ContractType_ContractType_MAX;
  static const int ContractType_ARRAYSIZE =
    Contract_ContractType_ContractType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ContractType_descriptor() {
    return Contract_ContractType_descriptor();
  }
  static inline const ::std::string& ContractType_Name(ContractType value) {
    return Contract_ContractType_Name(value);
  }
  static inline bool ContractType_Parse(const ::std::string& name,
      ContractType* value) {
    return Contract_ContractType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .protocol.Contract.ContractType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::protocol::Contract_ContractType type() const;
  void set_type(::protocol::Contract_ContractType value);

  // optional string payload = 2;
  void clear_payload();
  static const int kPayloadFieldNumber = 2;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  void set_payload(const char* value);
  void set_payload(const char* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:protocol.Contract)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static Contract* default_instance_;
};
// -------------------------------------------------------------------

class OperationCreateAccount : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationCreateAccount) */ {
 public:
  OperationCreateAccount();
  virtual ~OperationCreateAccount();

  OperationCreateAccount(const OperationCreateAccount& from);

  inline OperationCreateAccount& operator=(const OperationCreateAccount& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationCreateAccount& default_instance();

  void Swap(OperationCreateAccount* other);

  // implements Message ----------------------------------------------

  inline OperationCreateAccount* New() const { return New(NULL); }

  OperationCreateAccount* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationCreateAccount& from);
  void MergeFrom(const OperationCreateAccount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OperationCreateAccount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dest_address = 1;
  void clear_dest_address();
  static const int kDestAddressFieldNumber = 1;
  const ::std::string& dest_address() const;
  void set_dest_address(const ::std::string& value);
  void set_dest_address(const char* value);
  void set_dest_address(const char* value, size_t size);
  ::std::string* mutable_dest_address();
  ::std::string* release_dest_address();
  void set_allocated_dest_address(::std::string* dest_address);

  // optional .protocol.Contract contract = 2;
  bool has_contract() const;
  void clear_contract();
  static const int kContractFieldNumber = 2;
  const ::protocol::Contract& contract() const;
  ::protocol::Contract* mutable_contract();
  ::protocol::Contract* release_contract();
  void set_allocated_contract(::protocol::Contract* contract);

  // optional .protocol.AccountPrivilege priv = 3;
  bool has_priv() const;
  void clear_priv();
  static const int kPrivFieldNumber = 3;
  const ::protocol::AccountPrivilege& priv() const;
  ::protocol::AccountPrivilege* mutable_priv();
  ::protocol::AccountPrivilege* release_priv();
  void set_allocated_priv(::protocol::AccountPrivilege* priv);

  // repeated .protocol.KeyPair metadatas = 4;
  int metadatas_size() const;
  void clear_metadatas();
  static const int kMetadatasFieldNumber = 4;
  const ::protocol::KeyPair& metadatas(int index) const;
  ::protocol::KeyPair* mutable_metadatas(int index);
  ::protocol::KeyPair* add_metadatas();
  ::google::protobuf::RepeatedPtrField< ::protocol::KeyPair >*
      mutable_metadatas();
  const ::google::protobuf::RepeatedPtrField< ::protocol::KeyPair >&
      metadatas() const;

  // optional int64 init_balance = 5;
  void clear_init_balance();
  static const int kInitBalanceFieldNumber = 5;
  ::google::protobuf::int64 init_balance() const;
  void set_init_balance(::google::protobuf::int64 value);

  // optional string init_input = 6;
  void clear_init_input();
  static const int kInitInputFieldNumber = 6;
  const ::std::string& init_input() const;
  void set_init_input(const ::std::string& value);
  void set_init_input(const char* value);
  void set_init_input(const char* value, size_t size);
  ::std::string* mutable_init_input();
  ::std::string* release_init_input();
  void set_allocated_init_input(::std::string* init_input);

  // @@protoc_insertion_point(class_scope:protocol.OperationCreateAccount)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr dest_address_;
  ::protocol::Contract* contract_;
  ::protocol::AccountPrivilege* priv_;
  ::google::protobuf::RepeatedPtrField< ::protocol::KeyPair > metadatas_;
  ::google::protobuf::int64 init_balance_;
  ::google::protobuf::internal::ArenaStringPtr init_input_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static OperationCreateAccount* default_instance_;
};
// -------------------------------------------------------------------

class OperationSetMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationSetMetadata) */ {
 public:
  OperationSetMetadata();
  virtual ~OperationSetMetadata();

  OperationSetMetadata(const OperationSetMetadata& from);

  inline OperationSetMetadata& operator=(const OperationSetMetadata& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationSetMetadata& default_instance();

  void Swap(OperationSetMetadata* other);

  // implements Message ----------------------------------------------

  inline OperationSetMetadata* New() const { return New(NULL); }

  OperationSetMetadata* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationSetMetadata& from);
  void MergeFrom(const OperationSetMetadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OperationSetMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional int64 version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  ::google::protobuf::int64 version() const;
  void set_version(::google::protobuf::int64 value);

  // optional bool delete_flag = 4;
  void clear_delete_flag();
  static const int kDeleteFlagFieldNumber = 4;
  bool delete_flag() const;
  void set_delete_flag(bool value);

  // @@protoc_insertion_point(class_scope:protocol.OperationSetMetadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::int64 version_;
  bool delete_flag_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chain_2eproto();
  friend void protobuf_AssignDesc_chain_2eproto();
  friend void protobuf_ShutdownFile_chain_2eproto();

  void InitAsDefaultInstance();
  static OperationSetMetadata* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Account

// optional string address = 1;
inline void Account::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::address() const {
  // @@protoc_insertion_point(field_get:protocol.Account.address)
  return address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Account.address)
}
inline void Account::set_address(const char* value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Account.address)
}
inline void Account::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Account.address)
}
inline ::std::string* Account::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Account.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_address() {
  // @@protoc_insertion_point(field_release:protocol.Account.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.address)
}

// optional int64 nonce = 2;
inline void Account::clear_nonce() {
  nonce_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Account::nonce() const {
  // @@protoc_insertion_point(field_get:protocol.Account.nonce)
  return nonce_;
}
inline void Account::set_nonce(::google::protobuf::int64 value) {
  
  nonce_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.nonce)
}

// optional .protocol.AccountPrivilege priv = 3;
inline bool Account::has_priv() const {
  return !_is_default_instance_ && priv_ != NULL;
}
inline void Account::clear_priv() {
  if (GetArenaNoVirtual() == NULL && priv_ != NULL) delete priv_;
  priv_ = NULL;
}
inline const ::protocol::AccountPrivilege& Account::priv() const {
  // @@protoc_insertion_point(field_get:protocol.Account.priv)
  return priv_ != NULL ? *priv_ : *default_instance_->priv_;
}
inline ::protocol::AccountPrivilege* Account::mutable_priv() {
  
  if (priv_ == NULL) {
    priv_ = new ::protocol::AccountPrivilege;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Account.priv)
  return priv_;
}
inline ::protocol::AccountPrivilege* Account::release_priv() {
  // @@protoc_insertion_point(field_release:protocol.Account.priv)
  
  ::protocol::AccountPrivilege* temp = priv_;
  priv_ = NULL;
  return temp;
}
inline void Account::set_allocated_priv(::protocol::AccountPrivilege* priv) {
  delete priv_;
  priv_ = priv;
  if (priv) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.priv)
}

// optional bytes metadatas_hash = 4;
inline void Account::clear_metadatas_hash() {
  metadatas_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::metadatas_hash() const {
  // @@protoc_insertion_point(field_get:protocol.Account.metadatas_hash)
  return metadatas_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_metadatas_hash(const ::std::string& value) {
  
  metadatas_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Account.metadatas_hash)
}
inline void Account::set_metadatas_hash(const char* value) {
  
  metadatas_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Account.metadatas_hash)
}
inline void Account::set_metadatas_hash(const void* value, size_t size) {
  
  metadatas_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Account.metadatas_hash)
}
inline ::std::string* Account::mutable_metadatas_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Account.metadatas_hash)
  return metadatas_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_metadatas_hash() {
  // @@protoc_insertion_point(field_release:protocol.Account.metadatas_hash)
  
  return metadatas_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_metadatas_hash(::std::string* metadatas_hash) {
  if (metadatas_hash != NULL) {
    
  } else {
    
  }
  metadatas_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadatas_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.metadatas_hash)
}

// optional bytes assets_hash = 5;
inline void Account::clear_assets_hash() {
  assets_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::assets_hash() const {
  // @@protoc_insertion_point(field_get:protocol.Account.assets_hash)
  return assets_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_assets_hash(const ::std::string& value) {
  
  assets_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Account.assets_hash)
}
inline void Account::set_assets_hash(const char* value) {
  
  assets_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Account.assets_hash)
}
inline void Account::set_assets_hash(const void* value, size_t size) {
  
  assets_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Account.assets_hash)
}
inline ::std::string* Account::mutable_assets_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Account.assets_hash)
  return assets_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_assets_hash() {
  // @@protoc_insertion_point(field_release:protocol.Account.assets_hash)
  
  return assets_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_assets_hash(::std::string* assets_hash) {
  if (assets_hash != NULL) {
    
  } else {
    
  }
  assets_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), assets_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.assets_hash)
}

// optional .protocol.Contract contract = 6;
inline bool Account::has_contract() const {
  return !_is_default_instance_ && contract_ != NULL;
}
inline void Account::clear_contract() {
  if (GetArenaNoVirtual() == NULL && contract_ != NULL) delete contract_;
  contract_ = NULL;
}
inline const ::protocol::Contract& Account::contract() const {
  // @@protoc_insertion_point(field_get:protocol.Account.contract)
  return contract_ != NULL ? *contract_ : *default_instance_->contract_;
}
inline ::protocol::Contract* Account::mutable_contract() {
  
  if (contract_ == NULL) {
    contract_ = new ::protocol::Contract;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Account.contract)
  return contract_;
}
inline ::protocol::Contract* Account::release_contract() {
  // @@protoc_insertion_point(field_release:protocol.Account.contract)
  
  ::protocol::Contract* temp = contract_;
  contract_ = NULL;
  return temp;
}
inline void Account::set_allocated_contract(::protocol::Contract* contract) {
  delete contract_;
  contract_ = contract;
  if (contract) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.contract)
}

// optional int64 balance = 7;
inline void Account::clear_balance() {
  balance_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Account::balance() const {
  // @@protoc_insertion_point(field_get:protocol.Account.balance)
  return balance_;
}
inline void Account::set_balance(::google::protobuf::int64 value) {
  
  balance_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.balance)
}

// -------------------------------------------------------------------

// AssetKey

// optional string issuer = 1;
inline void AssetKey::clear_issuer() {
  issuer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AssetKey::issuer() const {
  // @@protoc_insertion_point(field_get:protocol.AssetKey.issuer)
  return issuer_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssetKey::set_issuer(const ::std::string& value) {
  
  issuer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.AssetKey.issuer)
}
inline void AssetKey::set_issuer(const char* value) {
  
  issuer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.AssetKey.issuer)
}
inline void AssetKey::set_issuer(const char* value, size_t size) {
  
  issuer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.AssetKey.issuer)
}
inline ::std::string* AssetKey::mutable_issuer() {
  
  // @@protoc_insertion_point(field_mutable:protocol.AssetKey.issuer)
  return issuer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AssetKey::release_issuer() {
  // @@protoc_insertion_point(field_release:protocol.AssetKey.issuer)
  
  return issuer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssetKey::set_allocated_issuer(::std::string* issuer) {
  if (issuer != NULL) {
    
  } else {
    
  }
  issuer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), issuer);
  // @@protoc_insertion_point(field_set_allocated:protocol.AssetKey.issuer)
}

// optional string code = 2;
inline void AssetKey::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AssetKey::code() const {
  // @@protoc_insertion_point(field_get:protocol.AssetKey.code)
  return code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssetKey::set_code(const ::std::string& value) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.AssetKey.code)
}
inline void AssetKey::set_code(const char* value) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.AssetKey.code)
}
inline void AssetKey::set_code(const char* value, size_t size) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.AssetKey.code)
}
inline ::std::string* AssetKey::mutable_code() {
  
  // @@protoc_insertion_point(field_mutable:protocol.AssetKey.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AssetKey::release_code() {
  // @@protoc_insertion_point(field_release:protocol.AssetKey.code)
  
  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssetKey::set_allocated_code(::std::string* code) {
  if (code != NULL) {
    
  } else {
    
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:protocol.AssetKey.code)
}

// optional int32 type = 3;
inline void AssetKey::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 AssetKey::type() const {
  // @@protoc_insertion_point(field_get:protocol.AssetKey.type)
  return type_;
}
inline void AssetKey::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.AssetKey.type)
}

// -------------------------------------------------------------------

// Asset

// optional .protocol.AssetKey key = 1;
inline bool Asset::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void Asset::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::protocol::AssetKey& Asset::key() const {
  // @@protoc_insertion_point(field_get:protocol.Asset.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::protocol::AssetKey* Asset::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::protocol::AssetKey;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Asset.key)
  return key_;
}
inline ::protocol::AssetKey* Asset::release_key() {
  // @@protoc_insertion_point(field_release:protocol.Asset.key)
  
  ::protocol::AssetKey* temp = key_;
  key_ = NULL;
  return temp;
}
inline void Asset::set_allocated_key(::protocol::AssetKey* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Asset.key)
}

// optional int64 amount = 2;
inline void Asset::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Asset::amount() const {
  // @@protoc_insertion_point(field_get:protocol.Asset.amount)
  return amount_;
}
inline void Asset::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:protocol.Asset.amount)
}

// -------------------------------------------------------------------

// AssetProperty

// optional int32 decimal = 1;
inline void AssetProperty::clear_decimal() {
  decimal_ = 0;
}
inline ::google::protobuf::int32 AssetProperty::decimal() const {
  // @@protoc_insertion_point(field_get:protocol.AssetProperty.decimal)
  return decimal_;
}
inline void AssetProperty::set_decimal(::google::protobuf::int32 value) {
  
  decimal_ = value;
  // @@protoc_insertion_point(field_set:protocol.AssetProperty.decimal)
}

// optional string description = 2;
inline void AssetProperty::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AssetProperty::description() const {
  // @@protoc_insertion_point(field_get:protocol.AssetProperty.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssetProperty::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.AssetProperty.description)
}
inline void AssetProperty::set_description(const char* value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.AssetProperty.description)
}
inline void AssetProperty::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.AssetProperty.description)
}
inline ::std::string* AssetProperty::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:protocol.AssetProperty.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AssetProperty::release_description() {
  // @@protoc_insertion_point(field_release:protocol.AssetProperty.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssetProperty::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:protocol.AssetProperty.description)
}

// optional int64 max_supply = 3;
inline void AssetProperty::clear_max_supply() {
  max_supply_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AssetProperty::max_supply() const {
  // @@protoc_insertion_point(field_get:protocol.AssetProperty.max_supply)
  return max_supply_;
}
inline void AssetProperty::set_max_supply(::google::protobuf::int64 value) {
  
  max_supply_ = value;
  // @@protoc_insertion_point(field_set:protocol.AssetProperty.max_supply)
}

// optional int64 issued_amount = 4;
inline void AssetProperty::clear_issued_amount() {
  issued_amount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AssetProperty::issued_amount() const {
  // @@protoc_insertion_point(field_get:protocol.AssetProperty.issued_amount)
  return issued_amount_;
}
inline void AssetProperty::set_issued_amount(::google::protobuf::int64 value) {
  
  issued_amount_ = value;
  // @@protoc_insertion_point(field_set:protocol.AssetProperty.issued_amount)
}

// optional int32 fee_percent = 5;
inline void AssetProperty::clear_fee_percent() {
  fee_percent_ = 0;
}
inline ::google::protobuf::int32 AssetProperty::fee_percent() const {
  // @@protoc_insertion_point(field_get:protocol.AssetProperty.fee_percent)
  return fee_percent_;
}
inline void AssetProperty::set_fee_percent(::google::protobuf::int32 value) {
  
  fee_percent_ = value;
  // @@protoc_insertion_point(field_set:protocol.AssetProperty.fee_percent)
}

// -------------------------------------------------------------------

// AssetStore

// optional .protocol.AssetKey key = 1;
inline bool AssetStore::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void AssetStore::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::protocol::AssetKey& AssetStore::key() const {
  // @@protoc_insertion_point(field_get:protocol.AssetStore.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::protocol::AssetKey* AssetStore::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::protocol::AssetKey;
  }
  // @@protoc_insertion_point(field_mutable:protocol.AssetStore.key)
  return key_;
}
inline ::protocol::AssetKey* AssetStore::release_key() {
  // @@protoc_insertion_point(field_release:protocol.AssetStore.key)
  
  ::protocol::AssetKey* temp = key_;
  key_ = NULL;
  return temp;
}
inline void AssetStore::set_allocated_key(::protocol::AssetKey* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.AssetStore.key)
}

// optional int64 amount = 2;
inline void AssetStore::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AssetStore::amount() const {
  // @@protoc_insertion_point(field_get:protocol.AssetStore.amount)
  return amount_;
}
inline void AssetStore::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:protocol.AssetStore.amount)
}

// optional .protocol.AssetProperty property = 3;
inline bool AssetStore::has_property() const {
  return !_is_default_instance_ && property_ != NULL;
}
inline void AssetStore::clear_property() {
  if (GetArenaNoVirtual() == NULL && property_ != NULL) delete property_;
  property_ = NULL;
}
inline const ::protocol::AssetProperty& AssetStore::property() const {
  // @@protoc_insertion_point(field_get:protocol.AssetStore.property)
  return property_ != NULL ? *property_ : *default_instance_->property_;
}
inline ::protocol::AssetProperty* AssetStore::mutable_property() {
  
  if (property_ == NULL) {
    property_ = new ::protocol::AssetProperty;
  }
  // @@protoc_insertion_point(field_mutable:protocol.AssetStore.property)
  return property_;
}
inline ::protocol::AssetProperty* AssetStore::release_property() {
  // @@protoc_insertion_point(field_release:protocol.AssetStore.property)
  
  ::protocol::AssetProperty* temp = property_;
  property_ = NULL;
  return temp;
}
inline void AssetStore::set_allocated_property(::protocol::AssetProperty* property) {
  delete property_;
  property_ = property;
  if (property) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.AssetStore.property)
}

// -------------------------------------------------------------------

// LedgerHeader

// optional int64 seq = 1;
inline void LedgerHeader::clear_seq() {
  seq_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LedgerHeader::seq() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.seq)
  return seq_;
}
inline void LedgerHeader::set_seq(::google::protobuf::int64 value) {
  
  seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.seq)
}

// optional bytes hash = 2;
inline void LedgerHeader::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LedgerHeader::hash() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.hash)
  return hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.hash)
}
inline void LedgerHeader::set_hash(const char* value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LedgerHeader.hash)
}
inline void LedgerHeader::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LedgerHeader.hash)
}
inline ::std::string* LedgerHeader::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.LedgerHeader.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.LedgerHeader.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.LedgerHeader.hash)
}

// optional bytes previous_hash = 3;
inline void LedgerHeader::clear_previous_hash() {
  previous_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LedgerHeader::previous_hash() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.previous_hash)
  return previous_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_previous_hash(const ::std::string& value) {
  
  previous_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.previous_hash)
}
inline void LedgerHeader::set_previous_hash(const char* value) {
  
  previous_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LedgerHeader.previous_hash)
}
inline void LedgerHeader::set_previous_hash(const void* value, size_t size) {
  
  previous_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LedgerHeader.previous_hash)
}
inline ::std::string* LedgerHeader::mutable_previous_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.LedgerHeader.previous_hash)
  return previous_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_previous_hash() {
  // @@protoc_insertion_point(field_release:protocol.LedgerHeader.previous_hash)
  
  return previous_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_previous_hash(::std::string* previous_hash) {
  if (previous_hash != NULL) {
    
  } else {
    
  }
  previous_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), previous_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.LedgerHeader.previous_hash)
}

// optional bytes account_tree_hash = 4;
inline void LedgerHeader::clear_account_tree_hash() {
  account_tree_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LedgerHeader::account_tree_hash() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.account_tree_hash)
  return account_tree_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_account_tree_hash(const ::std::string& value) {
  
  account_tree_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.account_tree_hash)
}
inline void LedgerHeader::set_account_tree_hash(const char* value) {
  
  account_tree_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LedgerHeader.account_tree_hash)
}
inline void LedgerHeader::set_account_tree_hash(const void* value, size_t size) {
  
  account_tree_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LedgerHeader.account_tree_hash)
}
inline ::std::string* LedgerHeader::mutable_account_tree_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.LedgerHeader.account_tree_hash)
  return account_tree_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_account_tree_hash() {
  // @@protoc_insertion_point(field_release:protocol.LedgerHeader.account_tree_hash)
  
  return account_tree_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_account_tree_hash(::std::string* account_tree_hash) {
  if (account_tree_hash != NULL) {
    
  } else {
    
  }
  account_tree_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_tree_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.LedgerHeader.account_tree_hash)
}

// optional int64 close_time = 5;
inline void LedgerHeader::clear_close_time() {
  close_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LedgerHeader::close_time() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.close_time)
  return close_time_;
}
inline void LedgerHeader::set_close_time(::google::protobuf::int64 value) {
  
  close_time_ = value;
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.close_time)
}

// optional bytes consensus_value_hash = 6;
inline void LedgerHeader::clear_consensus_value_hash() {
  consensus_value_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LedgerHeader::consensus_value_hash() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.consensus_value_hash)
  return consensus_value_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_consensus_value_hash(const ::std::string& value) {
  
  consensus_value_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.consensus_value_hash)
}
inline void LedgerHeader::set_consensus_value_hash(const char* value) {
  
  consensus_value_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LedgerHeader.consensus_value_hash)
}
inline void LedgerHeader::set_consensus_value_hash(const void* value, size_t size) {
  
  consensus_value_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LedgerHeader.consensus_value_hash)
}
inline ::std::string* LedgerHeader::mutable_consensus_value_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.LedgerHeader.consensus_value_hash)
  return consensus_value_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_consensus_value_hash() {
  // @@protoc_insertion_point(field_release:protocol.LedgerHeader.consensus_value_hash)
  
  return consensus_value_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_consensus_value_hash(::std::string* consensus_value_hash) {
  if (consensus_value_hash != NULL) {
    
  } else {
    
  }
  consensus_value_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), consensus_value_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.LedgerHeader.consensus_value_hash)
}

// optional int64 version = 7;
inline void LedgerHeader::clear_version() {
  version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LedgerHeader::version() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.version)
  return version_;
}
inline void LedgerHeader::set_version(::google::protobuf::int64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.version)
}

// optional int64 tx_count = 8;
inline void LedgerHeader::clear_tx_count() {
  tx_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LedgerHeader::tx_count() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.tx_count)
  return tx_count_;
}
inline void LedgerHeader::set_tx_count(::google::protobuf::int64 value) {
  
  tx_count_ = value;
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.tx_count)
}

// optional bytes validators_hash = 9;
inline void LedgerHeader::clear_validators_hash() {
  validators_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LedgerHeader::validators_hash() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.validators_hash)
  return validators_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_validators_hash(const ::std::string& value) {
  
  validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.validators_hash)
}
inline void LedgerHeader::set_validators_hash(const char* value) {
  
  validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LedgerHeader.validators_hash)
}
inline void LedgerHeader::set_validators_hash(const void* value, size_t size) {
  
  validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LedgerHeader.validators_hash)
}
inline ::std::string* LedgerHeader::mutable_validators_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.LedgerHeader.validators_hash)
  return validators_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_validators_hash() {
  // @@protoc_insertion_point(field_release:protocol.LedgerHeader.validators_hash)
  
  return validators_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_validators_hash(::std::string* validators_hash) {
  if (validators_hash != NULL) {
    
  } else {
    
  }
  validators_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), validators_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.LedgerHeader.validators_hash)
}

// optional bytes fees_hash = 10;
inline void LedgerHeader::clear_fees_hash() {
  fees_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LedgerHeader::fees_hash() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.fees_hash)
  return fees_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_fees_hash(const ::std::string& value) {
  
  fees_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.fees_hash)
}
inline void LedgerHeader::set_fees_hash(const char* value) {
  
  fees_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LedgerHeader.fees_hash)
}
inline void LedgerHeader::set_fees_hash(const void* value, size_t size) {
  
  fees_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LedgerHeader.fees_hash)
}
inline ::std::string* LedgerHeader::mutable_fees_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.LedgerHeader.fees_hash)
  return fees_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_fees_hash() {
  // @@protoc_insertion_point(field_release:protocol.LedgerHeader.fees_hash)
  
  return fees_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_fees_hash(::std::string* fees_hash) {
  if (fees_hash != NULL) {
    
  } else {
    
  }
  fees_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fees_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.LedgerHeader.fees_hash)
}

// optional string reserve = 11;
inline void LedgerHeader::clear_reserve() {
  reserve_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LedgerHeader::reserve() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.reserve)
  return reserve_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_reserve(const ::std::string& value) {
  
  reserve_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.reserve)
}
inline void LedgerHeader::set_reserve(const char* value) {
  
  reserve_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LedgerHeader.reserve)
}
inline void LedgerHeader::set_reserve(const char* value, size_t size) {
  
  reserve_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LedgerHeader.reserve)
}
inline ::std::string* LedgerHeader::mutable_reserve() {
  
  // @@protoc_insertion_point(field_mutable:protocol.LedgerHeader.reserve)
  return reserve_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_reserve() {
  // @@protoc_insertion_point(field_release:protocol.LedgerHeader.reserve)
  
  return reserve_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_reserve(::std::string* reserve) {
  if (reserve != NULL) {
    
  } else {
    
  }
  reserve_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reserve);
  // @@protoc_insertion_point(field_set_allocated:protocol.LedgerHeader.reserve)
}

// -------------------------------------------------------------------

// Ledger

// optional .protocol.LedgerHeader header = 1;
inline bool Ledger::has_header() const {
  return !_is_default_instance_ && header_ != NULL;
}
inline void Ledger::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::protocol::LedgerHeader& Ledger::header() const {
  // @@protoc_insertion_point(field_get:protocol.Ledger.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::protocol::LedgerHeader* Ledger::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::protocol::LedgerHeader;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Ledger.header)
  return header_;
}
inline ::protocol::LedgerHeader* Ledger::release_header() {
  // @@protoc_insertion_point(field_release:protocol.Ledger.header)
  
  ::protocol::LedgerHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Ledger::set_allocated_header(::protocol::LedgerHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Ledger.header)
}

// repeated .protocol.TransactionEnv transaction_envs = 2;
inline int Ledger::transaction_envs_size() const {
  return transaction_envs_.size();
}
inline void Ledger::clear_transaction_envs() {
  transaction_envs_.Clear();
}
inline const ::protocol::TransactionEnv& Ledger::transaction_envs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Ledger.transaction_envs)
  return transaction_envs_.Get(index);
}
inline ::protocol::TransactionEnv* Ledger::mutable_transaction_envs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Ledger.transaction_envs)
  return transaction_envs_.Mutable(index);
}
inline ::protocol::TransactionEnv* Ledger::add_transaction_envs() {
  // @@protoc_insertion_point(field_add:protocol.Ledger.transaction_envs)
  return transaction_envs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv >*
Ledger::mutable_transaction_envs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Ledger.transaction_envs)
  return &transaction_envs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv >&
Ledger::transaction_envs() const {
  // @@protoc_insertion_point(field_list:protocol.Ledger.transaction_envs)
  return transaction_envs_;
}

// -------------------------------------------------------------------

// OperationPayAsset

// optional string dest_address = 1;
inline void OperationPayAsset::clear_dest_address() {
  dest_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationPayAsset::dest_address() const {
  // @@protoc_insertion_point(field_get:protocol.OperationPayAsset.dest_address)
  return dest_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationPayAsset::set_dest_address(const ::std::string& value) {
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationPayAsset.dest_address)
}
inline void OperationPayAsset::set_dest_address(const char* value) {
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationPayAsset.dest_address)
}
inline void OperationPayAsset::set_dest_address(const char* value, size_t size) {
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationPayAsset.dest_address)
}
inline ::std::string* OperationPayAsset::mutable_dest_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.OperationPayAsset.dest_address)
  return dest_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationPayAsset::release_dest_address() {
  // @@protoc_insertion_point(field_release:protocol.OperationPayAsset.dest_address)
  
  return dest_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationPayAsset::set_allocated_dest_address(::std::string* dest_address) {
  if (dest_address != NULL) {
    
  } else {
    
  }
  dest_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationPayAsset.dest_address)
}

// optional .protocol.Asset asset = 2;
inline bool OperationPayAsset::has_asset() const {
  return !_is_default_instance_ && asset_ != NULL;
}
inline void OperationPayAsset::clear_asset() {
  if (GetArenaNoVirtual() == NULL && asset_ != NULL) delete asset_;
  asset_ = NULL;
}
inline const ::protocol::Asset& OperationPayAsset::asset() const {
  // @@protoc_insertion_point(field_get:protocol.OperationPayAsset.asset)
  return asset_ != NULL ? *asset_ : *default_instance_->asset_;
}
inline ::protocol::Asset* OperationPayAsset::mutable_asset() {
  
  if (asset_ == NULL) {
    asset_ = new ::protocol::Asset;
  }
  // @@protoc_insertion_point(field_mutable:protocol.OperationPayAsset.asset)
  return asset_;
}
inline ::protocol::Asset* OperationPayAsset::release_asset() {
  // @@protoc_insertion_point(field_release:protocol.OperationPayAsset.asset)
  
  ::protocol::Asset* temp = asset_;
  asset_ = NULL;
  return temp;
}
inline void OperationPayAsset::set_allocated_asset(::protocol::Asset* asset) {
  delete asset_;
  asset_ = asset;
  if (asset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationPayAsset.asset)
}

// optional string input = 3;
inline void OperationPayAsset::clear_input() {
  input_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationPayAsset::input() const {
  // @@protoc_insertion_point(field_get:protocol.OperationPayAsset.input)
  return input_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationPayAsset::set_input(const ::std::string& value) {
  
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationPayAsset.input)
}
inline void OperationPayAsset::set_input(const char* value) {
  
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationPayAsset.input)
}
inline void OperationPayAsset::set_input(const char* value, size_t size) {
  
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationPayAsset.input)
}
inline ::std::string* OperationPayAsset::mutable_input() {
  
  // @@protoc_insertion_point(field_mutable:protocol.OperationPayAsset.input)
  return input_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationPayAsset::release_input() {
  // @@protoc_insertion_point(field_release:protocol.OperationPayAsset.input)
  
  return input_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationPayAsset::set_allocated_input(::std::string* input) {
  if (input != NULL) {
    
  } else {
    
  }
  input_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationPayAsset.input)
}

// -------------------------------------------------------------------

// OperationTypeThreshold

// optional .protocol.Operation.Type type = 1;
inline void OperationTypeThreshold::clear_type() {
  type_ = 0;
}
inline ::protocol::Operation_Type OperationTypeThreshold::type() const {
  // @@protoc_insertion_point(field_get:protocol.OperationTypeThreshold.type)
  return static_cast< ::protocol::Operation_Type >(type_);
}
inline void OperationTypeThreshold::set_type(::protocol::Operation_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.OperationTypeThreshold.type)
}

// optional int64 threshold = 2;
inline void OperationTypeThreshold::clear_threshold() {
  threshold_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 OperationTypeThreshold::threshold() const {
  // @@protoc_insertion_point(field_get:protocol.OperationTypeThreshold.threshold)
  return threshold_;
}
inline void OperationTypeThreshold::set_threshold(::google::protobuf::int64 value) {
  
  threshold_ = value;
  // @@protoc_insertion_point(field_set:protocol.OperationTypeThreshold.threshold)
}

// -------------------------------------------------------------------

// AccountPrivilege

// optional int64 master_weight = 1;
inline void AccountPrivilege::clear_master_weight() {
  master_weight_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountPrivilege::master_weight() const {
  // @@protoc_insertion_point(field_get:protocol.AccountPrivilege.master_weight)
  return master_weight_;
}
inline void AccountPrivilege::set_master_weight(::google::protobuf::int64 value) {
  
  master_weight_ = value;
  // @@protoc_insertion_point(field_set:protocol.AccountPrivilege.master_weight)
}

// repeated .protocol.Signer signers = 2;
inline int AccountPrivilege::signers_size() const {
  return signers_.size();
}
inline void AccountPrivilege::clear_signers() {
  signers_.Clear();
}
inline const ::protocol::Signer& AccountPrivilege::signers(int index) const {
  // @@protoc_insertion_point(field_get:protocol.AccountPrivilege.signers)
  return signers_.Get(index);
}
inline ::protocol::Signer* AccountPrivilege::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.AccountPrivilege.signers)
  return signers_.Mutable(index);
}
inline ::protocol::Signer* AccountPrivilege::add_signers() {
  // @@protoc_insertion_point(field_add:protocol.AccountPrivilege.signers)
  return signers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Signer >*
AccountPrivilege::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:protocol.AccountPrivilege.signers)
  return &signers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Signer >&
AccountPrivilege::signers() const {
  // @@protoc_insertion_point(field_list:protocol.AccountPrivilege.signers)
  return signers_;
}

// optional .protocol.AccountThreshold thresholds = 3;
inline bool AccountPrivilege::has_thresholds() const {
  return !_is_default_instance_ && thresholds_ != NULL;
}
inline void AccountPrivilege::clear_thresholds() {
  if (GetArenaNoVirtual() == NULL && thresholds_ != NULL) delete thresholds_;
  thresholds_ = NULL;
}
inline const ::protocol::AccountThreshold& AccountPrivilege::thresholds() const {
  // @@protoc_insertion_point(field_get:protocol.AccountPrivilege.thresholds)
  return thresholds_ != NULL ? *thresholds_ : *default_instance_->thresholds_;
}
inline ::protocol::AccountThreshold* AccountPrivilege::mutable_thresholds() {
  
  if (thresholds_ == NULL) {
    thresholds_ = new ::protocol::AccountThreshold;
  }
  // @@protoc_insertion_point(field_mutable:protocol.AccountPrivilege.thresholds)
  return thresholds_;
}
inline ::protocol::AccountThreshold* AccountPrivilege::release_thresholds() {
  // @@protoc_insertion_point(field_release:protocol.AccountPrivilege.thresholds)
  
  ::protocol::AccountThreshold* temp = thresholds_;
  thresholds_ = NULL;
  return temp;
}
inline void AccountPrivilege::set_allocated_thresholds(::protocol::AccountThreshold* thresholds) {
  delete thresholds_;
  thresholds_ = thresholds;
  if (thresholds) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountPrivilege.thresholds)
}

// -------------------------------------------------------------------

// AccountThreshold

// optional int64 tx_threshold = 1;
inline void AccountThreshold::clear_tx_threshold() {
  tx_threshold_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountThreshold::tx_threshold() const {
  // @@protoc_insertion_point(field_get:protocol.AccountThreshold.tx_threshold)
  return tx_threshold_;
}
inline void AccountThreshold::set_tx_threshold(::google::protobuf::int64 value) {
  
  tx_threshold_ = value;
  // @@protoc_insertion_point(field_set:protocol.AccountThreshold.tx_threshold)
}

// repeated .protocol.OperationTypeThreshold type_thresholds = 2;
inline int AccountThreshold::type_thresholds_size() const {
  return type_thresholds_.size();
}
inline void AccountThreshold::clear_type_thresholds() {
  type_thresholds_.Clear();
}
inline const ::protocol::OperationTypeThreshold& AccountThreshold::type_thresholds(int index) const {
  // @@protoc_insertion_point(field_get:protocol.AccountThreshold.type_thresholds)
  return type_thresholds_.Get(index);
}
inline ::protocol::OperationTypeThreshold* AccountThreshold::mutable_type_thresholds(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.AccountThreshold.type_thresholds)
  return type_thresholds_.Mutable(index);
}
inline ::protocol::OperationTypeThreshold* AccountThreshold::add_type_thresholds() {
  // @@protoc_insertion_point(field_add:protocol.AccountThreshold.type_thresholds)
  return type_thresholds_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::OperationTypeThreshold >*
AccountThreshold::mutable_type_thresholds() {
  // @@protoc_insertion_point(field_mutable_list:protocol.AccountThreshold.type_thresholds)
  return &type_thresholds_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::OperationTypeThreshold >&
AccountThreshold::type_thresholds() const {
  // @@protoc_insertion_point(field_list:protocol.AccountThreshold.type_thresholds)
  return type_thresholds_;
}

// -------------------------------------------------------------------

// OperationIssueAsset

// optional string code = 1;
inline void OperationIssueAsset::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationIssueAsset::code() const {
  // @@protoc_insertion_point(field_get:protocol.OperationIssueAsset.code)
  return code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationIssueAsset::set_code(const ::std::string& value) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationIssueAsset.code)
}
inline void OperationIssueAsset::set_code(const char* value) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationIssueAsset.code)
}
inline void OperationIssueAsset::set_code(const char* value, size_t size) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationIssueAsset.code)
}
inline ::std::string* OperationIssueAsset::mutable_code() {
  
  // @@protoc_insertion_point(field_mutable:protocol.OperationIssueAsset.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationIssueAsset::release_code() {
  // @@protoc_insertion_point(field_release:protocol.OperationIssueAsset.code)
  
  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationIssueAsset::set_allocated_code(::std::string* code) {
  if (code != NULL) {
    
  } else {
    
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationIssueAsset.code)
}

// optional int64 amount = 2;
inline void OperationIssueAsset::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 OperationIssueAsset::amount() const {
  // @@protoc_insertion_point(field_get:protocol.OperationIssueAsset.amount)
  return amount_;
}
inline void OperationIssueAsset::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:protocol.OperationIssueAsset.amount)
}

// -------------------------------------------------------------------

// OperationPayCoin

// optional string dest_address = 1;
inline void OperationPayCoin::clear_dest_address() {
  dest_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationPayCoin::dest_address() const {
  // @@protoc_insertion_point(field_get:protocol.OperationPayCoin.dest_address)
  return dest_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationPayCoin::set_dest_address(const ::std::string& value) {
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationPayCoin.dest_address)
}
inline void OperationPayCoin::set_dest_address(const char* value) {
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationPayCoin.dest_address)
}
inline void OperationPayCoin::set_dest_address(const char* value, size_t size) {
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationPayCoin.dest_address)
}
inline ::std::string* OperationPayCoin::mutable_dest_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.OperationPayCoin.dest_address)
  return dest_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationPayCoin::release_dest_address() {
  // @@protoc_insertion_point(field_release:protocol.OperationPayCoin.dest_address)
  
  return dest_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationPayCoin::set_allocated_dest_address(::std::string* dest_address) {
  if (dest_address != NULL) {
    
  } else {
    
  }
  dest_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationPayCoin.dest_address)
}

// optional int64 amount = 2;
inline void OperationPayCoin::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 OperationPayCoin::amount() const {
  // @@protoc_insertion_point(field_get:protocol.OperationPayCoin.amount)
  return amount_;
}
inline void OperationPayCoin::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:protocol.OperationPayCoin.amount)
}

// optional string input = 3;
inline void OperationPayCoin::clear_input() {
  input_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationPayCoin::input() const {
  // @@protoc_insertion_point(field_get:protocol.OperationPayCoin.input)
  return input_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationPayCoin::set_input(const ::std::string& value) {
  
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationPayCoin.input)
}
inline void OperationPayCoin::set_input(const char* value) {
  
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationPayCoin.input)
}
inline void OperationPayCoin::set_input(const char* value, size_t size) {
  
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationPayCoin.input)
}
inline ::std::string* OperationPayCoin::mutable_input() {
  
  // @@protoc_insertion_point(field_mutable:protocol.OperationPayCoin.input)
  return input_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationPayCoin::release_input() {
  // @@protoc_insertion_point(field_release:protocol.OperationPayCoin.input)
  
  return input_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationPayCoin::set_allocated_input(::std::string* input) {
  if (input != NULL) {
    
  } else {
    
  }
  input_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationPayCoin.input)
}

// -------------------------------------------------------------------

// OperationSetSignerWeight

// optional int64 master_weight = 1;
inline void OperationSetSignerWeight::clear_master_weight() {
  master_weight_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 OperationSetSignerWeight::master_weight() const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetSignerWeight.master_weight)
  return master_weight_;
}
inline void OperationSetSignerWeight::set_master_weight(::google::protobuf::int64 value) {
  
  master_weight_ = value;
  // @@protoc_insertion_point(field_set:protocol.OperationSetSignerWeight.master_weight)
}

// repeated .protocol.Signer signers = 2;
inline int OperationSetSignerWeight::signers_size() const {
  return signers_.size();
}
inline void OperationSetSignerWeight::clear_signers() {
  signers_.Clear();
}
inline const ::protocol::Signer& OperationSetSignerWeight::signers(int index) const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetSignerWeight.signers)
  return signers_.Get(index);
}
inline ::protocol::Signer* OperationSetSignerWeight::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.OperationSetSignerWeight.signers)
  return signers_.Mutable(index);
}
inline ::protocol::Signer* OperationSetSignerWeight::add_signers() {
  // @@protoc_insertion_point(field_add:protocol.OperationSetSignerWeight.signers)
  return signers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Signer >*
OperationSetSignerWeight::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:protocol.OperationSetSignerWeight.signers)
  return &signers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Signer >&
OperationSetSignerWeight::signers() const {
  // @@protoc_insertion_point(field_list:protocol.OperationSetSignerWeight.signers)
  return signers_;
}

// -------------------------------------------------------------------

// OperationLog

// optional string topic = 1;
inline void OperationLog::clear_topic() {
  topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationLog::topic() const {
  // @@protoc_insertion_point(field_get:protocol.OperationLog.topic)
  return topic_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationLog::set_topic(const ::std::string& value) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationLog.topic)
}
inline void OperationLog::set_topic(const char* value) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationLog.topic)
}
inline void OperationLog::set_topic(const char* value, size_t size) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationLog.topic)
}
inline ::std::string* OperationLog::mutable_topic() {
  
  // @@protoc_insertion_point(field_mutable:protocol.OperationLog.topic)
  return topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationLog::release_topic() {
  // @@protoc_insertion_point(field_release:protocol.OperationLog.topic)
  
  return topic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationLog::set_allocated_topic(::std::string* topic) {
  if (topic != NULL) {
    
  } else {
    
  }
  topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationLog.topic)
}

// repeated string datas = 2;
inline int OperationLog::datas_size() const {
  return datas_.size();
}
inline void OperationLog::clear_datas() {
  datas_.Clear();
}
inline const ::std::string& OperationLog::datas(int index) const {
  // @@protoc_insertion_point(field_get:protocol.OperationLog.datas)
  return datas_.Get(index);
}
inline ::std::string* OperationLog::mutable_datas(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.OperationLog.datas)
  return datas_.Mutable(index);
}
inline void OperationLog::set_datas(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.OperationLog.datas)
  datas_.Mutable(index)->assign(value);
}
inline void OperationLog::set_datas(int index, const char* value) {
  datas_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.OperationLog.datas)
}
inline void OperationLog::set_datas(int index, const char* value, size_t size) {
  datas_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationLog.datas)
}
inline ::std::string* OperationLog::add_datas() {
  // @@protoc_insertion_point(field_add_mutable:protocol.OperationLog.datas)
  return datas_.Add();
}
inline void OperationLog::add_datas(const ::std::string& value) {
  datas_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.OperationLog.datas)
}
inline void OperationLog::add_datas(const char* value) {
  datas_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.OperationLog.datas)
}
inline void OperationLog::add_datas(const char* value, size_t size) {
  datas_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.OperationLog.datas)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OperationLog::datas() const {
  // @@protoc_insertion_point(field_list:protocol.OperationLog.datas)
  return datas_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OperationLog::mutable_datas() {
  // @@protoc_insertion_point(field_mutable_list:protocol.OperationLog.datas)
  return &datas_;
}

// -------------------------------------------------------------------

// OperationSetPrivilege

// optional string master_weight = 1;
inline void OperationSetPrivilege::clear_master_weight() {
  master_weight_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationSetPrivilege::master_weight() const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetPrivilege.master_weight)
  return master_weight_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationSetPrivilege::set_master_weight(const ::std::string& value) {
  
  master_weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationSetPrivilege.master_weight)
}
inline void OperationSetPrivilege::set_master_weight(const char* value) {
  
  master_weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationSetPrivilege.master_weight)
}
inline void OperationSetPrivilege::set_master_weight(const char* value, size_t size) {
  
  master_weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationSetPrivilege.master_weight)
}
inline ::std::string* OperationSetPrivilege::mutable_master_weight() {
  
  // @@protoc_insertion_point(field_mutable:protocol.OperationSetPrivilege.master_weight)
  return master_weight_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationSetPrivilege::release_master_weight() {
  // @@protoc_insertion_point(field_release:protocol.OperationSetPrivilege.master_weight)
  
  return master_weight_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationSetPrivilege::set_allocated_master_weight(::std::string* master_weight) {
  if (master_weight != NULL) {
    
  } else {
    
  }
  master_weight_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), master_weight);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationSetPrivilege.master_weight)
}

// repeated .protocol.Signer signers = 2;
inline int OperationSetPrivilege::signers_size() const {
  return signers_.size();
}
inline void OperationSetPrivilege::clear_signers() {
  signers_.Clear();
}
inline const ::protocol::Signer& OperationSetPrivilege::signers(int index) const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetPrivilege.signers)
  return signers_.Get(index);
}
inline ::protocol::Signer* OperationSetPrivilege::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.OperationSetPrivilege.signers)
  return signers_.Mutable(index);
}
inline ::protocol::Signer* OperationSetPrivilege::add_signers() {
  // @@protoc_insertion_point(field_add:protocol.OperationSetPrivilege.signers)
  return signers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Signer >*
OperationSetPrivilege::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:protocol.OperationSetPrivilege.signers)
  return &signers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Signer >&
OperationSetPrivilege::signers() const {
  // @@protoc_insertion_point(field_list:protocol.OperationSetPrivilege.signers)
  return signers_;
}

// optional string tx_threshold = 3;
inline void OperationSetPrivilege::clear_tx_threshold() {
  tx_threshold_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationSetPrivilege::tx_threshold() const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetPrivilege.tx_threshold)
  return tx_threshold_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationSetPrivilege::set_tx_threshold(const ::std::string& value) {
  
  tx_threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationSetPrivilege.tx_threshold)
}
inline void OperationSetPrivilege::set_tx_threshold(const char* value) {
  
  tx_threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationSetPrivilege.tx_threshold)
}
inline void OperationSetPrivilege::set_tx_threshold(const char* value, size_t size) {
  
  tx_threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationSetPrivilege.tx_threshold)
}
inline ::std::string* OperationSetPrivilege::mutable_tx_threshold() {
  
  // @@protoc_insertion_point(field_mutable:protocol.OperationSetPrivilege.tx_threshold)
  return tx_threshold_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationSetPrivilege::release_tx_threshold() {
  // @@protoc_insertion_point(field_release:protocol.OperationSetPrivilege.tx_threshold)
  
  return tx_threshold_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationSetPrivilege::set_allocated_tx_threshold(::std::string* tx_threshold) {
  if (tx_threshold != NULL) {
    
  } else {
    
  }
  tx_threshold_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_threshold);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationSetPrivilege.tx_threshold)
}

// repeated .protocol.OperationTypeThreshold type_thresholds = 4;
inline int OperationSetPrivilege::type_thresholds_size() const {
  return type_thresholds_.size();
}
inline void OperationSetPrivilege::clear_type_thresholds() {
  type_thresholds_.Clear();
}
inline const ::protocol::OperationTypeThreshold& OperationSetPrivilege::type_thresholds(int index) const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetPrivilege.type_thresholds)
  return type_thresholds_.Get(index);
}
inline ::protocol::OperationTypeThreshold* OperationSetPrivilege::mutable_type_thresholds(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.OperationSetPrivilege.type_thresholds)
  return type_thresholds_.Mutable(index);
}
inline ::protocol::OperationTypeThreshold* OperationSetPrivilege::add_type_thresholds() {
  // @@protoc_insertion_point(field_add:protocol.OperationSetPrivilege.type_thresholds)
  return type_thresholds_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::OperationTypeThreshold >*
OperationSetPrivilege::mutable_type_thresholds() {
  // @@protoc_insertion_point(field_mutable_list:protocol.OperationSetPrivilege.type_thresholds)
  return &type_thresholds_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::OperationTypeThreshold >&
OperationSetPrivilege::type_thresholds() const {
  // @@protoc_insertion_point(field_list:protocol.OperationSetPrivilege.type_thresholds)
  return type_thresholds_;
}

// -------------------------------------------------------------------

// Operation

// optional .protocol.Operation.Type type = 1;
inline void Operation::clear_type() {
  type_ = 0;
}
inline ::protocol::Operation_Type Operation::type() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.type)
  return static_cast< ::protocol::Operation_Type >(type_);
}
inline void Operation::set_type(::protocol::Operation_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.Operation.type)
}

// optional string source_address = 2;
inline void Operation::clear_source_address() {
  source_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Operation::source_address() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.source_address)
  return source_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Operation::set_source_address(const ::std::string& value) {
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Operation.source_address)
}
inline void Operation::set_source_address(const char* value) {
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Operation.source_address)
}
inline void Operation::set_source_address(const char* value, size_t size) {
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Operation.source_address)
}
inline ::std::string* Operation::mutable_source_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Operation.source_address)
  return source_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Operation::release_source_address() {
  // @@protoc_insertion_point(field_release:protocol.Operation.source_address)
  
  return source_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Operation::set_allocated_source_address(::std::string* source_address) {
  if (source_address != NULL) {
    
  } else {
    
  }
  source_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.source_address)
}

// optional bytes metadata = 3;
inline void Operation::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Operation::metadata() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.metadata)
  return metadata_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Operation::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Operation.metadata)
}
inline void Operation::set_metadata(const char* value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Operation.metadata)
}
inline void Operation::set_metadata(const void* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Operation.metadata)
}
inline ::std::string* Operation::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Operation.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Operation::release_metadata() {
  // @@protoc_insertion_point(field_release:protocol.Operation.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Operation::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.metadata)
}

// optional .protocol.OperationCreateAccount create_account = 4;
inline bool Operation::has_create_account() const {
  return !_is_default_instance_ && create_account_ != NULL;
}
inline void Operation::clear_create_account() {
  if (GetArenaNoVirtual() == NULL && create_account_ != NULL) delete create_account_;
  create_account_ = NULL;
}
inline const ::protocol::OperationCreateAccount& Operation::create_account() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.create_account)
  return create_account_ != NULL ? *create_account_ : *default_instance_->create_account_;
}
inline ::protocol::OperationCreateAccount* Operation::mutable_create_account() {
  
  if (create_account_ == NULL) {
    create_account_ = new ::protocol::OperationCreateAccount;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.create_account)
  return create_account_;
}
inline ::protocol::OperationCreateAccount* Operation::release_create_account() {
  // @@protoc_insertion_point(field_release:protocol.Operation.create_account)
  
  ::protocol::OperationCreateAccount* temp = create_account_;
  create_account_ = NULL;
  return temp;
}
inline void Operation::set_allocated_create_account(::protocol::OperationCreateAccount* create_account) {
  delete create_account_;
  create_account_ = create_account;
  if (create_account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.create_account)
}

// optional .protocol.OperationIssueAsset issue_asset = 5;
inline bool Operation::has_issue_asset() const {
  return !_is_default_instance_ && issue_asset_ != NULL;
}
inline void Operation::clear_issue_asset() {
  if (GetArenaNoVirtual() == NULL && issue_asset_ != NULL) delete issue_asset_;
  issue_asset_ = NULL;
}
inline const ::protocol::OperationIssueAsset& Operation::issue_asset() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.issue_asset)
  return issue_asset_ != NULL ? *issue_asset_ : *default_instance_->issue_asset_;
}
inline ::protocol::OperationIssueAsset* Operation::mutable_issue_asset() {
  
  if (issue_asset_ == NULL) {
    issue_asset_ = new ::protocol::OperationIssueAsset;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.issue_asset)
  return issue_asset_;
}
inline ::protocol::OperationIssueAsset* Operation::release_issue_asset() {
  // @@protoc_insertion_point(field_release:protocol.Operation.issue_asset)
  
  ::protocol::OperationIssueAsset* temp = issue_asset_;
  issue_asset_ = NULL;
  return temp;
}
inline void Operation::set_allocated_issue_asset(::protocol::OperationIssueAsset* issue_asset) {
  delete issue_asset_;
  issue_asset_ = issue_asset;
  if (issue_asset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.issue_asset)
}

// optional .protocol.OperationPayAsset pay_asset = 6;
inline bool Operation::has_pay_asset() const {
  return !_is_default_instance_ && pay_asset_ != NULL;
}
inline void Operation::clear_pay_asset() {
  if (GetArenaNoVirtual() == NULL && pay_asset_ != NULL) delete pay_asset_;
  pay_asset_ = NULL;
}
inline const ::protocol::OperationPayAsset& Operation::pay_asset() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.pay_asset)
  return pay_asset_ != NULL ? *pay_asset_ : *default_instance_->pay_asset_;
}
inline ::protocol::OperationPayAsset* Operation::mutable_pay_asset() {
  
  if (pay_asset_ == NULL) {
    pay_asset_ = new ::protocol::OperationPayAsset;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.pay_asset)
  return pay_asset_;
}
inline ::protocol::OperationPayAsset* Operation::release_pay_asset() {
  // @@protoc_insertion_point(field_release:protocol.Operation.pay_asset)
  
  ::protocol::OperationPayAsset* temp = pay_asset_;
  pay_asset_ = NULL;
  return temp;
}
inline void Operation::set_allocated_pay_asset(::protocol::OperationPayAsset* pay_asset) {
  delete pay_asset_;
  pay_asset_ = pay_asset;
  if (pay_asset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.pay_asset)
}

// optional .protocol.OperationSetMetadata set_metadata = 7;
inline bool Operation::has_set_metadata() const {
  return !_is_default_instance_ && set_metadata_ != NULL;
}
inline void Operation::clear_set_metadata() {
  if (GetArenaNoVirtual() == NULL && set_metadata_ != NULL) delete set_metadata_;
  set_metadata_ = NULL;
}
inline const ::protocol::OperationSetMetadata& Operation::set_metadata() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.set_metadata)
  return set_metadata_ != NULL ? *set_metadata_ : *default_instance_->set_metadata_;
}
inline ::protocol::OperationSetMetadata* Operation::mutable_set_metadata() {
  
  if (set_metadata_ == NULL) {
    set_metadata_ = new ::protocol::OperationSetMetadata;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.set_metadata)
  return set_metadata_;
}
inline ::protocol::OperationSetMetadata* Operation::release_set_metadata() {
  // @@protoc_insertion_point(field_release:protocol.Operation.set_metadata)
  
  ::protocol::OperationSetMetadata* temp = set_metadata_;
  set_metadata_ = NULL;
  return temp;
}
inline void Operation::set_allocated_set_metadata(::protocol::OperationSetMetadata* set_metadata) {
  delete set_metadata_;
  set_metadata_ = set_metadata;
  if (set_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.set_metadata)
}

// optional .protocol.OperationSetSignerWeight set_signer_weight = 8;
inline bool Operation::has_set_signer_weight() const {
  return !_is_default_instance_ && set_signer_weight_ != NULL;
}
inline void Operation::clear_set_signer_weight() {
  if (GetArenaNoVirtual() == NULL && set_signer_weight_ != NULL) delete set_signer_weight_;
  set_signer_weight_ = NULL;
}
inline const ::protocol::OperationSetSignerWeight& Operation::set_signer_weight() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.set_signer_weight)
  return set_signer_weight_ != NULL ? *set_signer_weight_ : *default_instance_->set_signer_weight_;
}
inline ::protocol::OperationSetSignerWeight* Operation::mutable_set_signer_weight() {
  
  if (set_signer_weight_ == NULL) {
    set_signer_weight_ = new ::protocol::OperationSetSignerWeight;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.set_signer_weight)
  return set_signer_weight_;
}
inline ::protocol::OperationSetSignerWeight* Operation::release_set_signer_weight() {
  // @@protoc_insertion_point(field_release:protocol.Operation.set_signer_weight)
  
  ::protocol::OperationSetSignerWeight* temp = set_signer_weight_;
  set_signer_weight_ = NULL;
  return temp;
}
inline void Operation::set_allocated_set_signer_weight(::protocol::OperationSetSignerWeight* set_signer_weight) {
  delete set_signer_weight_;
  set_signer_weight_ = set_signer_weight;
  if (set_signer_weight) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.set_signer_weight)
}

// optional .protocol.OperationSetThreshold set_threshold = 9;
inline bool Operation::has_set_threshold() const {
  return !_is_default_instance_ && set_threshold_ != NULL;
}
inline void Operation::clear_set_threshold() {
  if (GetArenaNoVirtual() == NULL && set_threshold_ != NULL) delete set_threshold_;
  set_threshold_ = NULL;
}
inline const ::protocol::OperationSetThreshold& Operation::set_threshold() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.set_threshold)
  return set_threshold_ != NULL ? *set_threshold_ : *default_instance_->set_threshold_;
}
inline ::protocol::OperationSetThreshold* Operation::mutable_set_threshold() {
  
  if (set_threshold_ == NULL) {
    set_threshold_ = new ::protocol::OperationSetThreshold;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.set_threshold)
  return set_threshold_;
}
inline ::protocol::OperationSetThreshold* Operation::release_set_threshold() {
  // @@protoc_insertion_point(field_release:protocol.Operation.set_threshold)
  
  ::protocol::OperationSetThreshold* temp = set_threshold_;
  set_threshold_ = NULL;
  return temp;
}
inline void Operation::set_allocated_set_threshold(::protocol::OperationSetThreshold* set_threshold) {
  delete set_threshold_;
  set_threshold_ = set_threshold;
  if (set_threshold) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.set_threshold)
}

// optional .protocol.OperationPayCoin pay_coin = 10;
inline bool Operation::has_pay_coin() const {
  return !_is_default_instance_ && pay_coin_ != NULL;
}
inline void Operation::clear_pay_coin() {
  if (GetArenaNoVirtual() == NULL && pay_coin_ != NULL) delete pay_coin_;
  pay_coin_ = NULL;
}
inline const ::protocol::OperationPayCoin& Operation::pay_coin() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.pay_coin)
  return pay_coin_ != NULL ? *pay_coin_ : *default_instance_->pay_coin_;
}
inline ::protocol::OperationPayCoin* Operation::mutable_pay_coin() {
  
  if (pay_coin_ == NULL) {
    pay_coin_ = new ::protocol::OperationPayCoin;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.pay_coin)
  return pay_coin_;
}
inline ::protocol::OperationPayCoin* Operation::release_pay_coin() {
  // @@protoc_insertion_point(field_release:protocol.Operation.pay_coin)
  
  ::protocol::OperationPayCoin* temp = pay_coin_;
  pay_coin_ = NULL;
  return temp;
}
inline void Operation::set_allocated_pay_coin(::protocol::OperationPayCoin* pay_coin) {
  delete pay_coin_;
  pay_coin_ = pay_coin;
  if (pay_coin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.pay_coin)
}

// optional .protocol.OperationLog log = 11;
inline bool Operation::has_log() const {
  return !_is_default_instance_ && log_ != NULL;
}
inline void Operation::clear_log() {
  if (GetArenaNoVirtual() == NULL && log_ != NULL) delete log_;
  log_ = NULL;
}
inline const ::protocol::OperationLog& Operation::log() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.log)
  return log_ != NULL ? *log_ : *default_instance_->log_;
}
inline ::protocol::OperationLog* Operation::mutable_log() {
  
  if (log_ == NULL) {
    log_ = new ::protocol::OperationLog;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.log)
  return log_;
}
inline ::protocol::OperationLog* Operation::release_log() {
  // @@protoc_insertion_point(field_release:protocol.Operation.log)
  
  ::protocol::OperationLog* temp = log_;
  log_ = NULL;
  return temp;
}
inline void Operation::set_allocated_log(::protocol::OperationLog* log) {
  delete log_;
  log_ = log;
  if (log) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.log)
}

// optional .protocol.OperationSetPrivilege set_privilege = 12;
inline bool Operation::has_set_privilege() const {
  return !_is_default_instance_ && set_privilege_ != NULL;
}
inline void Operation::clear_set_privilege() {
  if (GetArenaNoVirtual() == NULL && set_privilege_ != NULL) delete set_privilege_;
  set_privilege_ = NULL;
}
inline const ::protocol::OperationSetPrivilege& Operation::set_privilege() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.set_privilege)
  return set_privilege_ != NULL ? *set_privilege_ : *default_instance_->set_privilege_;
}
inline ::protocol::OperationSetPrivilege* Operation::mutable_set_privilege() {
  
  if (set_privilege_ == NULL) {
    set_privilege_ = new ::protocol::OperationSetPrivilege;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.set_privilege)
  return set_privilege_;
}
inline ::protocol::OperationSetPrivilege* Operation::release_set_privilege() {
  // @@protoc_insertion_point(field_release:protocol.Operation.set_privilege)
  
  ::protocol::OperationSetPrivilege* temp = set_privilege_;
  set_privilege_ = NULL;
  return temp;
}
inline void Operation::set_allocated_set_privilege(::protocol::OperationSetPrivilege* set_privilege) {
  delete set_privilege_;
  set_privilege_ = set_privilege;
  if (set_privilege) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.set_privilege)
}

// -------------------------------------------------------------------

// OperationSetThreshold

// optional int64 tx_threshold = 1;
inline void OperationSetThreshold::clear_tx_threshold() {
  tx_threshold_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 OperationSetThreshold::tx_threshold() const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetThreshold.tx_threshold)
  return tx_threshold_;
}
inline void OperationSetThreshold::set_tx_threshold(::google::protobuf::int64 value) {
  
  tx_threshold_ = value;
  // @@protoc_insertion_point(field_set:protocol.OperationSetThreshold.tx_threshold)
}

// repeated .protocol.OperationTypeThreshold type_thresholds = 2;
inline int OperationSetThreshold::type_thresholds_size() const {
  return type_thresholds_.size();
}
inline void OperationSetThreshold::clear_type_thresholds() {
  type_thresholds_.Clear();
}
inline const ::protocol::OperationTypeThreshold& OperationSetThreshold::type_thresholds(int index) const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetThreshold.type_thresholds)
  return type_thresholds_.Get(index);
}
inline ::protocol::OperationTypeThreshold* OperationSetThreshold::mutable_type_thresholds(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.OperationSetThreshold.type_thresholds)
  return type_thresholds_.Mutable(index);
}
inline ::protocol::OperationTypeThreshold* OperationSetThreshold::add_type_thresholds() {
  // @@protoc_insertion_point(field_add:protocol.OperationSetThreshold.type_thresholds)
  return type_thresholds_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::OperationTypeThreshold >*
OperationSetThreshold::mutable_type_thresholds() {
  // @@protoc_insertion_point(field_mutable_list:protocol.OperationSetThreshold.type_thresholds)
  return &type_thresholds_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::OperationTypeThreshold >&
OperationSetThreshold::type_thresholds() const {
  // @@protoc_insertion_point(field_list:protocol.OperationSetThreshold.type_thresholds)
  return type_thresholds_;
}

// -------------------------------------------------------------------

// Transaction

// optional string source_address = 1;
inline void Transaction::clear_source_address() {
  source_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::source_address() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.source_address)
  return source_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_source_address(const ::std::string& value) {
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.source_address)
}
inline void Transaction::set_source_address(const char* value) {
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.source_address)
}
inline void Transaction::set_source_address(const char* value, size_t size) {
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.source_address)
}
inline ::std::string* Transaction::mutable_source_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.source_address)
  return source_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_source_address() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.source_address)
  
  return source_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_source_address(::std::string* source_address) {
  if (source_address != NULL) {
    
  } else {
    
  }
  source_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.source_address)
}

// optional int64 nonce = 2;
inline void Transaction::clear_nonce() {
  nonce_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction::nonce() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.nonce)
  return nonce_;
}
inline void Transaction::set_nonce(::google::protobuf::int64 value) {
  
  nonce_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.nonce)
}

// optional int64 fee_limit = 3;
inline void Transaction::clear_fee_limit() {
  fee_limit_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction::fee_limit() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.fee_limit)
  return fee_limit_;
}
inline void Transaction::set_fee_limit(::google::protobuf::int64 value) {
  
  fee_limit_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.fee_limit)
}

// optional int64 gas_price = 4;
inline void Transaction::clear_gas_price() {
  gas_price_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction::gas_price() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.gas_price)
  return gas_price_;
}
inline void Transaction::set_gas_price(::google::protobuf::int64 value) {
  
  gas_price_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.gas_price)
}

// optional int64 ceil_ledger_seq = 5;
inline void Transaction::clear_ceil_ledger_seq() {
  ceil_ledger_seq_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction::ceil_ledger_seq() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.ceil_ledger_seq)
  return ceil_ledger_seq_;
}
inline void Transaction::set_ceil_ledger_seq(::google::protobuf::int64 value) {
  
  ceil_ledger_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.ceil_ledger_seq)
}

// optional bytes metadata = 6;
inline void Transaction::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::metadata() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.metadata)
  return metadata_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.metadata)
}
inline void Transaction::set_metadata(const char* value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.metadata)
}
inline void Transaction::set_metadata(const void* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.metadata)
}
inline ::std::string* Transaction::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_metadata() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.metadata)
}

// repeated .protocol.Operation operations = 7;
inline int Transaction::operations_size() const {
  return operations_.size();
}
inline void Transaction::clear_operations() {
  operations_.Clear();
}
inline const ::protocol::Operation& Transaction::operations(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.operations)
  return operations_.Get(index);
}
inline ::protocol::Operation* Transaction::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.operations)
  return operations_.Mutable(index);
}
inline ::protocol::Operation* Transaction::add_operations() {
  // @@protoc_insertion_point(field_add:protocol.Transaction.operations)
  return operations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Operation >*
Transaction::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.operations)
  return &operations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Operation >&
Transaction::operations() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.operations)
  return operations_;
}

// -------------------------------------------------------------------

// Signer

// optional string address = 1;
inline void Signer::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Signer::address() const {
  // @@protoc_insertion_point(field_get:protocol.Signer.address)
  return address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signer::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Signer.address)
}
inline void Signer::set_address(const char* value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Signer.address)
}
inline void Signer::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Signer.address)
}
inline ::std::string* Signer::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Signer.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signer::release_address() {
  // @@protoc_insertion_point(field_release:protocol.Signer.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signer::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:protocol.Signer.address)
}

// optional int64 weight = 2;
inline void Signer::clear_weight() {
  weight_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Signer::weight() const {
  // @@protoc_insertion_point(field_get:protocol.Signer.weight)
  return weight_;
}
inline void Signer::set_weight(::google::protobuf::int64 value) {
  
  weight_ = value;
  // @@protoc_insertion_point(field_set:protocol.Signer.weight)
}

// -------------------------------------------------------------------

// Trigger_OperationTrigger

// optional bytes hash = 1;
inline void Trigger_OperationTrigger::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Trigger_OperationTrigger::hash() const {
  // @@protoc_insertion_point(field_get:protocol.Trigger.OperationTrigger.hash)
  return hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Trigger_OperationTrigger::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Trigger.OperationTrigger.hash)
}
inline void Trigger_OperationTrigger::set_hash(const char* value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Trigger.OperationTrigger.hash)
}
inline void Trigger_OperationTrigger::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Trigger.OperationTrigger.hash)
}
inline ::std::string* Trigger_OperationTrigger::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Trigger.OperationTrigger.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Trigger_OperationTrigger::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.Trigger.OperationTrigger.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Trigger_OperationTrigger::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.Trigger.OperationTrigger.hash)
}

// optional int64 index = 2;
inline void Trigger_OperationTrigger::clear_index() {
  index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Trigger_OperationTrigger::index() const {
  // @@protoc_insertion_point(field_get:protocol.Trigger.OperationTrigger.index)
  return index_;
}
inline void Trigger_OperationTrigger::set_index(::google::protobuf::int64 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:protocol.Trigger.OperationTrigger.index)
}

// -------------------------------------------------------------------

// Trigger

// optional .protocol.Trigger.TransactionType transaction_type = 1;
inline void Trigger::clear_transaction_type() {
  transaction_type_ = 0;
}
inline ::protocol::Trigger_TransactionType Trigger::transaction_type() const {
  // @@protoc_insertion_point(field_get:protocol.Trigger.transaction_type)
  return static_cast< ::protocol::Trigger_TransactionType >(transaction_type_);
}
inline void Trigger::set_transaction_type(::protocol::Trigger_TransactionType value) {
  
  transaction_type_ = value;
  // @@protoc_insertion_point(field_set:protocol.Trigger.transaction_type)
}

// optional int64 ledger_seq = 2;
inline void Trigger::clear_ledger_seq() {
  ledger_seq_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Trigger::ledger_seq() const {
  // @@protoc_insertion_point(field_get:protocol.Trigger.ledger_seq)
  return ledger_seq_;
}
inline void Trigger::set_ledger_seq(::google::protobuf::int64 value) {
  
  ledger_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.Trigger.ledger_seq)
}

// optional .protocol.Trigger.OperationTrigger transaction = 3;
inline bool Trigger::has_transaction() const {
  return !_is_default_instance_ && transaction_ != NULL;
}
inline void Trigger::clear_transaction() {
  if (GetArenaNoVirtual() == NULL && transaction_ != NULL) delete transaction_;
  transaction_ = NULL;
}
inline const ::protocol::Trigger_OperationTrigger& Trigger::transaction() const {
  // @@protoc_insertion_point(field_get:protocol.Trigger.transaction)
  return transaction_ != NULL ? *transaction_ : *default_instance_->transaction_;
}
inline ::protocol::Trigger_OperationTrigger* Trigger::mutable_transaction() {
  
  if (transaction_ == NULL) {
    transaction_ = new ::protocol::Trigger_OperationTrigger;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Trigger.transaction)
  return transaction_;
}
inline ::protocol::Trigger_OperationTrigger* Trigger::release_transaction() {
  // @@protoc_insertion_point(field_release:protocol.Trigger.transaction)
  
  ::protocol::Trigger_OperationTrigger* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline void Trigger::set_allocated_transaction(::protocol::Trigger_OperationTrigger* transaction) {
  delete transaction_;
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Trigger.transaction)
}

// -------------------------------------------------------------------

// TransactionEnv

// optional .protocol.Transaction transaction = 1;
inline bool TransactionEnv::has_transaction() const {
  return !_is_default_instance_ && transaction_ != NULL;
}
inline void TransactionEnv::clear_transaction() {
  if (GetArenaNoVirtual() == NULL && transaction_ != NULL) delete transaction_;
  transaction_ = NULL;
}
inline const ::protocol::Transaction& TransactionEnv::transaction() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnv.transaction)
  return transaction_ != NULL ? *transaction_ : *default_instance_->transaction_;
}
inline ::protocol::Transaction* TransactionEnv::mutable_transaction() {
  
  if (transaction_ == NULL) {
    transaction_ = new ::protocol::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:protocol.TransactionEnv.transaction)
  return transaction_;
}
inline ::protocol::Transaction* TransactionEnv::release_transaction() {
  // @@protoc_insertion_point(field_release:protocol.TransactionEnv.transaction)
  
  ::protocol::Transaction* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline void TransactionEnv::set_allocated_transaction(::protocol::Transaction* transaction) {
  delete transaction_;
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionEnv.transaction)
}

// repeated .protocol.Signature signatures = 2;
inline int TransactionEnv::signatures_size() const {
  return signatures_.size();
}
inline void TransactionEnv::clear_signatures() {
  signatures_.Clear();
}
inline const ::protocol::Signature& TransactionEnv::signatures(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnv.signatures)
  return signatures_.Get(index);
}
inline ::protocol::Signature* TransactionEnv::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionEnv.signatures)
  return signatures_.Mutable(index);
}
inline ::protocol::Signature* TransactionEnv::add_signatures() {
  // @@protoc_insertion_point(field_add:protocol.TransactionEnv.signatures)
  return signatures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Signature >*
TransactionEnv::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionEnv.signatures)
  return &signatures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Signature >&
TransactionEnv::signatures() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionEnv.signatures)
  return signatures_;
}

// optional .protocol.Trigger trigger = 3;
inline bool TransactionEnv::has_trigger() const {
  return !_is_default_instance_ && trigger_ != NULL;
}
inline void TransactionEnv::clear_trigger() {
  if (GetArenaNoVirtual() == NULL && trigger_ != NULL) delete trigger_;
  trigger_ = NULL;
}
inline const ::protocol::Trigger& TransactionEnv::trigger() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnv.trigger)
  return trigger_ != NULL ? *trigger_ : *default_instance_->trigger_;
}
inline ::protocol::Trigger* TransactionEnv::mutable_trigger() {
  
  if (trigger_ == NULL) {
    trigger_ = new ::protocol::Trigger;
  }
  // @@protoc_insertion_point(field_mutable:protocol.TransactionEnv.trigger)
  return trigger_;
}
inline ::protocol::Trigger* TransactionEnv::release_trigger() {
  // @@protoc_insertion_point(field_release:protocol.TransactionEnv.trigger)
  
  ::protocol::Trigger* temp = trigger_;
  trigger_ = NULL;
  return temp;
}
inline void TransactionEnv::set_allocated_trigger(::protocol::Trigger* trigger) {
  delete trigger_;
  trigger_ = trigger;
  if (trigger) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionEnv.trigger)
}

// -------------------------------------------------------------------

// TransactionEnvStore

// optional .protocol.TransactionEnv transaction_env = 1;
inline bool TransactionEnvStore::has_transaction_env() const {
  return !_is_default_instance_ && transaction_env_ != NULL;
}
inline void TransactionEnvStore::clear_transaction_env() {
  if (GetArenaNoVirtual() == NULL && transaction_env_ != NULL) delete transaction_env_;
  transaction_env_ = NULL;
}
inline const ::protocol::TransactionEnv& TransactionEnvStore::transaction_env() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnvStore.transaction_env)
  return transaction_env_ != NULL ? *transaction_env_ : *default_instance_->transaction_env_;
}
inline ::protocol::TransactionEnv* TransactionEnvStore::mutable_transaction_env() {
  
  if (transaction_env_ == NULL) {
    transaction_env_ = new ::protocol::TransactionEnv;
  }
  // @@protoc_insertion_point(field_mutable:protocol.TransactionEnvStore.transaction_env)
  return transaction_env_;
}
inline ::protocol::TransactionEnv* TransactionEnvStore::release_transaction_env() {
  // @@protoc_insertion_point(field_release:protocol.TransactionEnvStore.transaction_env)
  
  ::protocol::TransactionEnv* temp = transaction_env_;
  transaction_env_ = NULL;
  return temp;
}
inline void TransactionEnvStore::set_allocated_transaction_env(::protocol::TransactionEnv* transaction_env) {
  delete transaction_env_;
  transaction_env_ = transaction_env;
  if (transaction_env) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionEnvStore.transaction_env)
}

// optional int32 error_code = 2;
inline void TransactionEnvStore::clear_error_code() {
  error_code_ = 0;
}
inline ::google::protobuf::int32 TransactionEnvStore::error_code() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnvStore.error_code)
  return error_code_;
}
inline void TransactionEnvStore::set_error_code(::google::protobuf::int32 value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:protocol.TransactionEnvStore.error_code)
}

// optional string error_desc = 3;
inline void TransactionEnvStore::clear_error_desc() {
  error_desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionEnvStore::error_desc() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnvStore.error_desc)
  return error_desc_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionEnvStore::set_error_desc(const ::std::string& value) {
  
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TransactionEnvStore.error_desc)
}
inline void TransactionEnvStore::set_error_desc(const char* value) {
  
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TransactionEnvStore.error_desc)
}
inline void TransactionEnvStore::set_error_desc(const char* value, size_t size) {
  
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TransactionEnvStore.error_desc)
}
inline ::std::string* TransactionEnvStore::mutable_error_desc() {
  
  // @@protoc_insertion_point(field_mutable:protocol.TransactionEnvStore.error_desc)
  return error_desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionEnvStore::release_error_desc() {
  // @@protoc_insertion_point(field_release:protocol.TransactionEnvStore.error_desc)
  
  return error_desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionEnvStore::set_allocated_error_desc(::std::string* error_desc) {
  if (error_desc != NULL) {
    
  } else {
    
  }
  error_desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_desc);
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionEnvStore.error_desc)
}

// optional int64 ledger_seq = 4;
inline void TransactionEnvStore::clear_ledger_seq() {
  ledger_seq_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TransactionEnvStore::ledger_seq() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnvStore.ledger_seq)
  return ledger_seq_;
}
inline void TransactionEnvStore::set_ledger_seq(::google::protobuf::int64 value) {
  
  ledger_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.TransactionEnvStore.ledger_seq)
}

// optional int64 close_time = 5;
inline void TransactionEnvStore::clear_close_time() {
  close_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TransactionEnvStore::close_time() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnvStore.close_time)
  return close_time_;
}
inline void TransactionEnvStore::set_close_time(::google::protobuf::int64 value) {
  
  close_time_ = value;
  // @@protoc_insertion_point(field_set:protocol.TransactionEnvStore.close_time)
}

// optional bytes hash = 6;
inline void TransactionEnvStore::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionEnvStore::hash() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnvStore.hash)
  return hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionEnvStore::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TransactionEnvStore.hash)
}
inline void TransactionEnvStore::set_hash(const char* value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TransactionEnvStore.hash)
}
inline void TransactionEnvStore::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TransactionEnvStore.hash)
}
inline ::std::string* TransactionEnvStore::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.TransactionEnvStore.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionEnvStore::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.TransactionEnvStore.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionEnvStore::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionEnvStore.hash)
}

// optional int64 actual_fee = 7;
inline void TransactionEnvStore::clear_actual_fee() {
  actual_fee_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TransactionEnvStore::actual_fee() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnvStore.actual_fee)
  return actual_fee_;
}
inline void TransactionEnvStore::set_actual_fee(::google::protobuf::int64 value) {
  
  actual_fee_ = value;
  // @@protoc_insertion_point(field_set:protocol.TransactionEnvStore.actual_fee)
}

// -------------------------------------------------------------------

// TransactionEnvSet

// repeated .protocol.TransactionEnv txs = 2;
inline int TransactionEnvSet::txs_size() const {
  return txs_.size();
}
inline void TransactionEnvSet::clear_txs() {
  txs_.Clear();
}
inline const ::protocol::TransactionEnv& TransactionEnvSet::txs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnvSet.txs)
  return txs_.Get(index);
}
inline ::protocol::TransactionEnv* TransactionEnvSet::mutable_txs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionEnvSet.txs)
  return txs_.Mutable(index);
}
inline ::protocol::TransactionEnv* TransactionEnvSet::add_txs() {
  // @@protoc_insertion_point(field_add:protocol.TransactionEnvSet.txs)
  return txs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv >*
TransactionEnvSet::mutable_txs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionEnvSet.txs)
  return &txs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv >&
TransactionEnvSet::txs() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionEnvSet.txs)
  return txs_;
}

// -------------------------------------------------------------------

// ConsensusValueValidation

// repeated int32 expire_tx_ids = 1;
inline int ConsensusValueValidation::expire_tx_ids_size() const {
  return expire_tx_ids_.size();
}
inline void ConsensusValueValidation::clear_expire_tx_ids() {
  expire_tx_ids_.Clear();
}
inline ::google::protobuf::int32 ConsensusValueValidation::expire_tx_ids(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ConsensusValueValidation.expire_tx_ids)
  return expire_tx_ids_.Get(index);
}
inline void ConsensusValueValidation::set_expire_tx_ids(int index, ::google::protobuf::int32 value) {
  expire_tx_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.ConsensusValueValidation.expire_tx_ids)
}
inline void ConsensusValueValidation::add_expire_tx_ids(::google::protobuf::int32 value) {
  expire_tx_ids_.Add(value);
  // @@protoc_insertion_point(field_add:protocol.ConsensusValueValidation.expire_tx_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ConsensusValueValidation::expire_tx_ids() const {
  // @@protoc_insertion_point(field_list:protocol.ConsensusValueValidation.expire_tx_ids)
  return expire_tx_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ConsensusValueValidation::mutable_expire_tx_ids() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ConsensusValueValidation.expire_tx_ids)
  return &expire_tx_ids_;
}

// repeated int32 error_tx_ids = 2;
inline int ConsensusValueValidation::error_tx_ids_size() const {
  return error_tx_ids_.size();
}
inline void ConsensusValueValidation::clear_error_tx_ids() {
  error_tx_ids_.Clear();
}
inline ::google::protobuf::int32 ConsensusValueValidation::error_tx_ids(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ConsensusValueValidation.error_tx_ids)
  return error_tx_ids_.Get(index);
}
inline void ConsensusValueValidation::set_error_tx_ids(int index, ::google::protobuf::int32 value) {
  error_tx_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.ConsensusValueValidation.error_tx_ids)
}
inline void ConsensusValueValidation::add_error_tx_ids(::google::protobuf::int32 value) {
  error_tx_ids_.Add(value);
  // @@protoc_insertion_point(field_add:protocol.ConsensusValueValidation.error_tx_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ConsensusValueValidation::error_tx_ids() const {
  // @@protoc_insertion_point(field_list:protocol.ConsensusValueValidation.error_tx_ids)
  return error_tx_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ConsensusValueValidation::mutable_error_tx_ids() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ConsensusValueValidation.error_tx_ids)
  return &error_tx_ids_;
}

// -------------------------------------------------------------------

// ConsensusValue

// optional .protocol.TransactionEnvSet txset = 1;
inline bool ConsensusValue::has_txset() const {
  return !_is_default_instance_ && txset_ != NULL;
}
inline void ConsensusValue::clear_txset() {
  if (GetArenaNoVirtual() == NULL && txset_ != NULL) delete txset_;
  txset_ = NULL;
}
inline const ::protocol::TransactionEnvSet& ConsensusValue::txset() const {
  // @@protoc_insertion_point(field_get:protocol.ConsensusValue.txset)
  return txset_ != NULL ? *txset_ : *default_instance_->txset_;
}
inline ::protocol::TransactionEnvSet* ConsensusValue::mutable_txset() {
  
  if (txset_ == NULL) {
    txset_ = new ::protocol::TransactionEnvSet;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ConsensusValue.txset)
  return txset_;
}
inline ::protocol::TransactionEnvSet* ConsensusValue::release_txset() {
  // @@protoc_insertion_point(field_release:protocol.ConsensusValue.txset)
  
  ::protocol::TransactionEnvSet* temp = txset_;
  txset_ = NULL;
  return temp;
}
inline void ConsensusValue::set_allocated_txset(::protocol::TransactionEnvSet* txset) {
  delete txset_;
  txset_ = txset;
  if (txset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.ConsensusValue.txset)
}

// optional int64 close_time = 2;
inline void ConsensusValue::clear_close_time() {
  close_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ConsensusValue::close_time() const {
  // @@protoc_insertion_point(field_get:protocol.ConsensusValue.close_time)
  return close_time_;
}
inline void ConsensusValue::set_close_time(::google::protobuf::int64 value) {
  
  close_time_ = value;
  // @@protoc_insertion_point(field_set:protocol.ConsensusValue.close_time)
}

// optional bytes previous_proof = 3;
inline void ConsensusValue::clear_previous_proof() {
  previous_proof_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConsensusValue::previous_proof() const {
  // @@protoc_insertion_point(field_get:protocol.ConsensusValue.previous_proof)
  return previous_proof_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConsensusValue::set_previous_proof(const ::std::string& value) {
  
  previous_proof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ConsensusValue.previous_proof)
}
inline void ConsensusValue::set_previous_proof(const char* value) {
  
  previous_proof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ConsensusValue.previous_proof)
}
inline void ConsensusValue::set_previous_proof(const void* value, size_t size) {
  
  previous_proof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ConsensusValue.previous_proof)
}
inline ::std::string* ConsensusValue::mutable_previous_proof() {
  
  // @@protoc_insertion_point(field_mutable:protocol.ConsensusValue.previous_proof)
  return previous_proof_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConsensusValue::release_previous_proof() {
  // @@protoc_insertion_point(field_release:protocol.ConsensusValue.previous_proof)
  
  return previous_proof_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConsensusValue::set_allocated_previous_proof(::std::string* previous_proof) {
  if (previous_proof != NULL) {
    
  } else {
    
  }
  previous_proof_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), previous_proof);
  // @@protoc_insertion_point(field_set_allocated:protocol.ConsensusValue.previous_proof)
}

// optional int64 ledger_seq = 4;
inline void ConsensusValue::clear_ledger_seq() {
  ledger_seq_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ConsensusValue::ledger_seq() const {
  // @@protoc_insertion_point(field_get:protocol.ConsensusValue.ledger_seq)
  return ledger_seq_;
}
inline void ConsensusValue::set_ledger_seq(::google::protobuf::int64 value) {
  
  ledger_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.ConsensusValue.ledger_seq)
}

// optional bytes previous_ledger_hash = 5;
inline void ConsensusValue::clear_previous_ledger_hash() {
  previous_ledger_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConsensusValue::previous_ledger_hash() const {
  // @@protoc_insertion_point(field_get:protocol.ConsensusValue.previous_ledger_hash)
  return previous_ledger_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConsensusValue::set_previous_ledger_hash(const ::std::string& value) {
  
  previous_ledger_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ConsensusValue.previous_ledger_hash)
}
inline void ConsensusValue::set_previous_ledger_hash(const char* value) {
  
  previous_ledger_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ConsensusValue.previous_ledger_hash)
}
inline void ConsensusValue::set_previous_ledger_hash(const void* value, size_t size) {
  
  previous_ledger_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ConsensusValue.previous_ledger_hash)
}
inline ::std::string* ConsensusValue::mutable_previous_ledger_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.ConsensusValue.previous_ledger_hash)
  return previous_ledger_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConsensusValue::release_previous_ledger_hash() {
  // @@protoc_insertion_point(field_release:protocol.ConsensusValue.previous_ledger_hash)
  
  return previous_ledger_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConsensusValue::set_allocated_previous_ledger_hash(::std::string* previous_ledger_hash) {
  if (previous_ledger_hash != NULL) {
    
  } else {
    
  }
  previous_ledger_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), previous_ledger_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.ConsensusValue.previous_ledger_hash)
}

// optional .protocol.LedgerUpgrade ledger_upgrade = 6;
inline bool ConsensusValue::has_ledger_upgrade() const {
  return !_is_default_instance_ && ledger_upgrade_ != NULL;
}
inline void ConsensusValue::clear_ledger_upgrade() {
  if (GetArenaNoVirtual() == NULL && ledger_upgrade_ != NULL) delete ledger_upgrade_;
  ledger_upgrade_ = NULL;
}
inline const ::protocol::LedgerUpgrade& ConsensusValue::ledger_upgrade() const {
  // @@protoc_insertion_point(field_get:protocol.ConsensusValue.ledger_upgrade)
  return ledger_upgrade_ != NULL ? *ledger_upgrade_ : *default_instance_->ledger_upgrade_;
}
inline ::protocol::LedgerUpgrade* ConsensusValue::mutable_ledger_upgrade() {
  
  if (ledger_upgrade_ == NULL) {
    ledger_upgrade_ = new ::protocol::LedgerUpgrade;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ConsensusValue.ledger_upgrade)
  return ledger_upgrade_;
}
inline ::protocol::LedgerUpgrade* ConsensusValue::release_ledger_upgrade() {
  // @@protoc_insertion_point(field_release:protocol.ConsensusValue.ledger_upgrade)
  
  ::protocol::LedgerUpgrade* temp = ledger_upgrade_;
  ledger_upgrade_ = NULL;
  return temp;
}
inline void ConsensusValue::set_allocated_ledger_upgrade(::protocol::LedgerUpgrade* ledger_upgrade) {
  delete ledger_upgrade_;
  ledger_upgrade_ = ledger_upgrade;
  if (ledger_upgrade) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.ConsensusValue.ledger_upgrade)
}

// optional .protocol.ConsensusValueValidation validation = 7;
inline bool ConsensusValue::has_validation() const {
  return !_is_default_instance_ && validation_ != NULL;
}
inline void ConsensusValue::clear_validation() {
  if (GetArenaNoVirtual() == NULL && validation_ != NULL) delete validation_;
  validation_ = NULL;
}
inline const ::protocol::ConsensusValueValidation& ConsensusValue::validation() const {
  // @@protoc_insertion_point(field_get:protocol.ConsensusValue.validation)
  return validation_ != NULL ? *validation_ : *default_instance_->validation_;
}
inline ::protocol::ConsensusValueValidation* ConsensusValue::mutable_validation() {
  
  if (validation_ == NULL) {
    validation_ = new ::protocol::ConsensusValueValidation;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ConsensusValue.validation)
  return validation_;
}
inline ::protocol::ConsensusValueValidation* ConsensusValue::release_validation() {
  // @@protoc_insertion_point(field_release:protocol.ConsensusValue.validation)
  
  ::protocol::ConsensusValueValidation* temp = validation_;
  validation_ = NULL;
  return temp;
}
inline void ConsensusValue::set_allocated_validation(::protocol::ConsensusValueValidation* validation) {
  delete validation_;
  validation_ = validation;
  if (validation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.ConsensusValue.validation)
}

// -------------------------------------------------------------------

// Contract

// optional .protocol.Contract.ContractType type = 1;
inline void Contract::clear_type() {
  type_ = 0;
}
inline ::protocol::Contract_ContractType Contract::type() const {
  // @@protoc_insertion_point(field_get:protocol.Contract.type)
  return static_cast< ::protocol::Contract_ContractType >(type_);
}
inline void Contract::set_type(::protocol::Contract_ContractType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.Contract.type)
}

// optional string payload = 2;
inline void Contract::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Contract::payload() const {
  // @@protoc_insertion_point(field_get:protocol.Contract.payload)
  return payload_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Contract::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Contract.payload)
}
inline void Contract::set_payload(const char* value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Contract.payload)
}
inline void Contract::set_payload(const char* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Contract.payload)
}
inline ::std::string* Contract::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Contract.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Contract::release_payload() {
  // @@protoc_insertion_point(field_release:protocol.Contract.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Contract::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:protocol.Contract.payload)
}

// -------------------------------------------------------------------

// OperationCreateAccount

// optional string dest_address = 1;
inline void OperationCreateAccount::clear_dest_address() {
  dest_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationCreateAccount::dest_address() const {
  // @@protoc_insertion_point(field_get:protocol.OperationCreateAccount.dest_address)
  return dest_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationCreateAccount::set_dest_address(const ::std::string& value) {
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationCreateAccount.dest_address)
}
inline void OperationCreateAccount::set_dest_address(const char* value) {
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationCreateAccount.dest_address)
}
inline void OperationCreateAccount::set_dest_address(const char* value, size_t size) {
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationCreateAccount.dest_address)
}
inline ::std::string* OperationCreateAccount::mutable_dest_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.OperationCreateAccount.dest_address)
  return dest_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationCreateAccount::release_dest_address() {
  // @@protoc_insertion_point(field_release:protocol.OperationCreateAccount.dest_address)
  
  return dest_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationCreateAccount::set_allocated_dest_address(::std::string* dest_address) {
  if (dest_address != NULL) {
    
  } else {
    
  }
  dest_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationCreateAccount.dest_address)
}

// optional .protocol.Contract contract = 2;
inline bool OperationCreateAccount::has_contract() const {
  return !_is_default_instance_ && contract_ != NULL;
}
inline void OperationCreateAccount::clear_contract() {
  if (GetArenaNoVirtual() == NULL && contract_ != NULL) delete contract_;
  contract_ = NULL;
}
inline const ::protocol::Contract& OperationCreateAccount::contract() const {
  // @@protoc_insertion_point(field_get:protocol.OperationCreateAccount.contract)
  return contract_ != NULL ? *contract_ : *default_instance_->contract_;
}
inline ::protocol::Contract* OperationCreateAccount::mutable_contract() {
  
  if (contract_ == NULL) {
    contract_ = new ::protocol::Contract;
  }
  // @@protoc_insertion_point(field_mutable:protocol.OperationCreateAccount.contract)
  return contract_;
}
inline ::protocol::Contract* OperationCreateAccount::release_contract() {
  // @@protoc_insertion_point(field_release:protocol.OperationCreateAccount.contract)
  
  ::protocol::Contract* temp = contract_;
  contract_ = NULL;
  return temp;
}
inline void OperationCreateAccount::set_allocated_contract(::protocol::Contract* contract) {
  delete contract_;
  contract_ = contract;
  if (contract) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationCreateAccount.contract)
}

// optional .protocol.AccountPrivilege priv = 3;
inline bool OperationCreateAccount::has_priv() const {
  return !_is_default_instance_ && priv_ != NULL;
}
inline void OperationCreateAccount::clear_priv() {
  if (GetArenaNoVirtual() == NULL && priv_ != NULL) delete priv_;
  priv_ = NULL;
}
inline const ::protocol::AccountPrivilege& OperationCreateAccount::priv() const {
  // @@protoc_insertion_point(field_get:protocol.OperationCreateAccount.priv)
  return priv_ != NULL ? *priv_ : *default_instance_->priv_;
}
inline ::protocol::AccountPrivilege* OperationCreateAccount::mutable_priv() {
  
  if (priv_ == NULL) {
    priv_ = new ::protocol::AccountPrivilege;
  }
  // @@protoc_insertion_point(field_mutable:protocol.OperationCreateAccount.priv)
  return priv_;
}
inline ::protocol::AccountPrivilege* OperationCreateAccount::release_priv() {
  // @@protoc_insertion_point(field_release:protocol.OperationCreateAccount.priv)
  
  ::protocol::AccountPrivilege* temp = priv_;
  priv_ = NULL;
  return temp;
}
inline void OperationCreateAccount::set_allocated_priv(::protocol::AccountPrivilege* priv) {
  delete priv_;
  priv_ = priv;
  if (priv) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationCreateAccount.priv)
}

// repeated .protocol.KeyPair metadatas = 4;
inline int OperationCreateAccount::metadatas_size() const {
  return metadatas_.size();
}
inline void OperationCreateAccount::clear_metadatas() {
  metadatas_.Clear();
}
inline const ::protocol::KeyPair& OperationCreateAccount::metadatas(int index) const {
  // @@protoc_insertion_point(field_get:protocol.OperationCreateAccount.metadatas)
  return metadatas_.Get(index);
}
inline ::protocol::KeyPair* OperationCreateAccount::mutable_metadatas(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.OperationCreateAccount.metadatas)
  return metadatas_.Mutable(index);
}
inline ::protocol::KeyPair* OperationCreateAccount::add_metadatas() {
  // @@protoc_insertion_point(field_add:protocol.OperationCreateAccount.metadatas)
  return metadatas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::KeyPair >*
OperationCreateAccount::mutable_metadatas() {
  // @@protoc_insertion_point(field_mutable_list:protocol.OperationCreateAccount.metadatas)
  return &metadatas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::KeyPair >&
OperationCreateAccount::metadatas() const {
  // @@protoc_insertion_point(field_list:protocol.OperationCreateAccount.metadatas)
  return metadatas_;
}

// optional int64 init_balance = 5;
inline void OperationCreateAccount::clear_init_balance() {
  init_balance_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 OperationCreateAccount::init_balance() const {
  // @@protoc_insertion_point(field_get:protocol.OperationCreateAccount.init_balance)
  return init_balance_;
}
inline void OperationCreateAccount::set_init_balance(::google::protobuf::int64 value) {
  
  init_balance_ = value;
  // @@protoc_insertion_point(field_set:protocol.OperationCreateAccount.init_balance)
}

// optional string init_input = 6;
inline void OperationCreateAccount::clear_init_input() {
  init_input_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationCreateAccount::init_input() const {
  // @@protoc_insertion_point(field_get:protocol.OperationCreateAccount.init_input)
  return init_input_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationCreateAccount::set_init_input(const ::std::string& value) {
  
  init_input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationCreateAccount.init_input)
}
inline void OperationCreateAccount::set_init_input(const char* value) {
  
  init_input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationCreateAccount.init_input)
}
inline void OperationCreateAccount::set_init_input(const char* value, size_t size) {
  
  init_input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationCreateAccount.init_input)
}
inline ::std::string* OperationCreateAccount::mutable_init_input() {
  
  // @@protoc_insertion_point(field_mutable:protocol.OperationCreateAccount.init_input)
  return init_input_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationCreateAccount::release_init_input() {
  // @@protoc_insertion_point(field_release:protocol.OperationCreateAccount.init_input)
  
  return init_input_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationCreateAccount::set_allocated_init_input(::std::string* init_input) {
  if (init_input != NULL) {
    
  } else {
    
  }
  init_input_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), init_input);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationCreateAccount.init_input)
}

// -------------------------------------------------------------------

// OperationSetMetadata

// optional string key = 1;
inline void OperationSetMetadata::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationSetMetadata::key() const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetMetadata.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationSetMetadata::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationSetMetadata.key)
}
inline void OperationSetMetadata::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationSetMetadata.key)
}
inline void OperationSetMetadata::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationSetMetadata.key)
}
inline ::std::string* OperationSetMetadata::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:protocol.OperationSetMetadata.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationSetMetadata::release_key() {
  // @@protoc_insertion_point(field_release:protocol.OperationSetMetadata.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationSetMetadata::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationSetMetadata.key)
}

// optional string value = 2;
inline void OperationSetMetadata::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationSetMetadata::value() const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetMetadata.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationSetMetadata::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationSetMetadata.value)
}
inline void OperationSetMetadata::set_value(const char* value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationSetMetadata.value)
}
inline void OperationSetMetadata::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationSetMetadata.value)
}
inline ::std::string* OperationSetMetadata::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:protocol.OperationSetMetadata.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationSetMetadata::release_value() {
  // @@protoc_insertion_point(field_release:protocol.OperationSetMetadata.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationSetMetadata::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationSetMetadata.value)
}

// optional int64 version = 3;
inline void OperationSetMetadata::clear_version() {
  version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 OperationSetMetadata::version() const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetMetadata.version)
  return version_;
}
inline void OperationSetMetadata::set_version(::google::protobuf::int64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:protocol.OperationSetMetadata.version)
}

// optional bool delete_flag = 4;
inline void OperationSetMetadata::clear_delete_flag() {
  delete_flag_ = false;
}
inline bool OperationSetMetadata::delete_flag() const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetMetadata.delete_flag)
  return delete_flag_;
}
inline void OperationSetMetadata::set_delete_flag(bool value) {
  
  delete_flag_ = value;
  // @@protoc_insertion_point(field_set:protocol.OperationSetMetadata.delete_flag)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::protocol::Operation_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Operation_Type>() {
  return ::protocol::Operation_Type_descriptor();
}
template <> struct is_proto_enum< ::protocol::Transaction_Limit> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Transaction_Limit>() {
  return ::protocol::Transaction_Limit_descriptor();
}
template <> struct is_proto_enum< ::protocol::Signer_Limit> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Signer_Limit>() {
  return ::protocol::Signer_Limit_descriptor();
}
template <> struct is_proto_enum< ::protocol::Trigger_TransactionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Trigger_TransactionType>() {
  return ::protocol::Trigger_TransactionType_descriptor();
}
template <> struct is_proto_enum< ::protocol::Contract_ContractType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Contract_ContractType>() {
  return ::protocol::Contract_ContractType_descriptor();
}
template <> struct is_proto_enum< ::protocol::Limit> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Limit>() {
  return ::protocol::Limit_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_chain_2eproto__INCLUDED
