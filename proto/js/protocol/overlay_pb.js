/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('./google-protobuf');
var goog = jspb;
var global = Function('return this')();

var common_pb = require('./common_pb.js');
var chain_pb = require('./chain_pb.js');
goog.exportSymbol('proto.protocol.ChainHello', null, global);
goog.exportSymbol('proto.protocol.ChainMessageType', null, global);
goog.exportSymbol('proto.protocol.ChainPeerMessage', null, global);
goog.exportSymbol('proto.protocol.ChainResponse', null, global);
goog.exportSymbol('proto.protocol.ChainStatus', null, global);
goog.exportSymbol('proto.protocol.ChainSubscribeTx', null, global);
goog.exportSymbol('proto.protocol.ChainTxStatus', null, global);
goog.exportSymbol('proto.protocol.ChainTxStatus.TxStatus', null, global);
goog.exportSymbol('proto.protocol.DontHave', null, global);
goog.exportSymbol('proto.protocol.EntryList', null, global);
goog.exportSymbol('proto.protocol.GetLedgers', null, global);
goog.exportSymbol('proto.protocol.Hello', null, global);
goog.exportSymbol('proto.protocol.HelloResponse', null, global);
goog.exportSymbol('proto.protocol.LedgerUpgradeNotify', null, global);
goog.exportSymbol('proto.protocol.Ledgers', null, global);
goog.exportSymbol('proto.protocol.Ledgers.SyncCode', null, global);
goog.exportSymbol('proto.protocol.OVERLAY_MESSAGE_TYPE', null, global);
goog.exportSymbol('proto.protocol.Peer', null, global);
goog.exportSymbol('proto.protocol.Peers', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.protocol.Hello = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.protocol.Hello, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.protocol.Hello.displayName = 'proto.protocol.Hello';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.protocol.Hello.prototype.toObject = function(opt_includeInstance) {
  return proto.protocol.Hello.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.protocol.Hello} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.Hello.toObject = function(includeInstance, msg) {
  var f, obj = {
    networkId: jspb.Message.getFieldWithDefault(msg, 1, 0),
    ledgerVersion: jspb.Message.getFieldWithDefault(msg, 2, 0),
    overlayVersion: jspb.Message.getFieldWithDefault(msg, 3, 0),
    phantomVersion: jspb.Message.getFieldWithDefault(msg, 4, ""),
    listeningPort: jspb.Message.getFieldWithDefault(msg, 5, 0),
    nodeAddress: jspb.Message.getFieldWithDefault(msg, 6, ""),
    nodeRand: jspb.Message.getFieldWithDefault(msg, 7, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.protocol.Hello}
 */
proto.protocol.Hello.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.protocol.Hello;
  return proto.protocol.Hello.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.protocol.Hello} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.protocol.Hello}
 */
proto.protocol.Hello.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setNetworkId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setLedgerVersion(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setOverlayVersion(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setPhantomVersion(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setListeningPort(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setNodeAddress(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setNodeRand(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.protocol.Hello.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.protocol.Hello.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.protocol.Hello} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.Hello.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNetworkId();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = message.getLedgerVersion();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getOverlayVersion();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getPhantomVersion();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getListeningPort();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getNodeAddress();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
  f = message.getNodeRand();
  if (f.length > 0) {
    writer.writeString(
      7,
      f
    );
  }
};


/**
 * optional int64 network_id = 1;
 * @return {number}
 */
proto.protocol.Hello.prototype.getNetworkId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.protocol.Hello.prototype.setNetworkId = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional int64 ledger_version = 2;
 * @return {number}
 */
proto.protocol.Hello.prototype.getLedgerVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.protocol.Hello.prototype.setLedgerVersion = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional int64 overlay_version = 3;
 * @return {number}
 */
proto.protocol.Hello.prototype.getOverlayVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.protocol.Hello.prototype.setOverlayVersion = function(value) {
  jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional string phantom_version = 4;
 * @return {string}
 */
proto.protocol.Hello.prototype.getPhantomVersion = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/** @param {string} value */
proto.protocol.Hello.prototype.setPhantomVersion = function(value) {
  jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional int64 listening_port = 5;
 * @return {number}
 */
proto.protocol.Hello.prototype.getListeningPort = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.protocol.Hello.prototype.setListeningPort = function(value) {
  jspb.Message.setProto3IntField(this, 5, value);
};


/**
 * optional string node_address = 6;
 * @return {string}
 */
proto.protocol.Hello.prototype.getNodeAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/** @param {string} value */
proto.protocol.Hello.prototype.setNodeAddress = function(value) {
  jspb.Message.setProto3StringField(this, 6, value);
};


/**
 * optional string node_rand = 7;
 * @return {string}
 */
proto.protocol.Hello.prototype.getNodeRand = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/** @param {string} value */
proto.protocol.Hello.prototype.setNodeRand = function(value) {
  jspb.Message.setProto3StringField(this, 7, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.protocol.HelloResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.protocol.HelloResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.protocol.HelloResponse.displayName = 'proto.protocol.HelloResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.protocol.HelloResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.protocol.HelloResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.protocol.HelloResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.HelloResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    errorCode: jspb.Message.getFieldWithDefault(msg, 1, 0),
    errorDesc: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.protocol.HelloResponse}
 */
proto.protocol.HelloResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.protocol.HelloResponse;
  return proto.protocol.HelloResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.protocol.HelloResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.protocol.HelloResponse}
 */
proto.protocol.HelloResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.protocol.ERRORCODE} */ (reader.readEnum());
      msg.setErrorCode(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setErrorDesc(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.protocol.HelloResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.protocol.HelloResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.protocol.HelloResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.HelloResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getErrorCode();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getErrorDesc();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional ERRORCODE error_code = 1;
 * @return {!proto.protocol.ERRORCODE}
 */
proto.protocol.HelloResponse.prototype.getErrorCode = function() {
  return /** @type {!proto.protocol.ERRORCODE} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {!proto.protocol.ERRORCODE} value */
proto.protocol.HelloResponse.prototype.setErrorCode = function(value) {
  jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional string error_desc = 2;
 * @return {string}
 */
proto.protocol.HelloResponse.prototype.getErrorDesc = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.protocol.HelloResponse.prototype.setErrorDesc = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.protocol.Peer = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.protocol.Peer, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.protocol.Peer.displayName = 'proto.protocol.Peer';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.protocol.Peer.prototype.toObject = function(opt_includeInstance) {
  return proto.protocol.Peer.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.protocol.Peer} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.Peer.toObject = function(includeInstance, msg) {
  var f, obj = {
    ip: jspb.Message.getFieldWithDefault(msg, 1, ""),
    port: jspb.Message.getFieldWithDefault(msg, 2, 0),
    numFailures: jspb.Message.getFieldWithDefault(msg, 3, 0),
    nextAttemptTime: jspb.Message.getFieldWithDefault(msg, 4, 0),
    activeTime: jspb.Message.getFieldWithDefault(msg, 5, 0),
    connectionId: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.protocol.Peer}
 */
proto.protocol.Peer.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.protocol.Peer;
  return proto.protocol.Peer.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.protocol.Peer} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.protocol.Peer}
 */
proto.protocol.Peer.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setIp(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setPort(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setNumFailures(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setNextAttemptTime(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setActiveTime(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setConnectionId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.protocol.Peer.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.protocol.Peer.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.protocol.Peer} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.Peer.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getIp();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getPort();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getNumFailures();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getNextAttemptTime();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = message.getActiveTime();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getConnectionId();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
};


/**
 * optional string ip = 1;
 * @return {string}
 */
proto.protocol.Peer.prototype.getIp = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.protocol.Peer.prototype.setIp = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional int64 port = 2;
 * @return {number}
 */
proto.protocol.Peer.prototype.getPort = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.protocol.Peer.prototype.setPort = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional int64 num_failures = 3;
 * @return {number}
 */
proto.protocol.Peer.prototype.getNumFailures = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.protocol.Peer.prototype.setNumFailures = function(value) {
  jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional int64 next_attempt_time = 4;
 * @return {number}
 */
proto.protocol.Peer.prototype.getNextAttemptTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.protocol.Peer.prototype.setNextAttemptTime = function(value) {
  jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional int64 active_time = 5;
 * @return {number}
 */
proto.protocol.Peer.prototype.getActiveTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.protocol.Peer.prototype.setActiveTime = function(value) {
  jspb.Message.setProto3IntField(this, 5, value);
};


/**
 * optional int64 connection_id = 6;
 * @return {number}
 */
proto.protocol.Peer.prototype.getConnectionId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.protocol.Peer.prototype.setConnectionId = function(value) {
  jspb.Message.setProto3IntField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.protocol.Peers = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.protocol.Peers.repeatedFields_, null);
};
goog.inherits(proto.protocol.Peers, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.protocol.Peers.displayName = 'proto.protocol.Peers';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.protocol.Peers.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.protocol.Peers.prototype.toObject = function(opt_includeInstance) {
  return proto.protocol.Peers.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.protocol.Peers} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.Peers.toObject = function(includeInstance, msg) {
  var f, obj = {
    peersList: jspb.Message.toObjectList(msg.getPeersList(),
    proto.protocol.Peer.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.protocol.Peers}
 */
proto.protocol.Peers.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.protocol.Peers;
  return proto.protocol.Peers.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.protocol.Peers} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.protocol.Peers}
 */
proto.protocol.Peers.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.protocol.Peer;
      reader.readMessage(value,proto.protocol.Peer.deserializeBinaryFromReader);
      msg.addPeers(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.protocol.Peers.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.protocol.Peers.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.protocol.Peers} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.Peers.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPeersList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.protocol.Peer.serializeBinaryToWriter
    );
  }
};


/**
 * repeated Peer peers = 1;
 * @return {!Array.<!proto.protocol.Peer>}
 */
proto.protocol.Peers.prototype.getPeersList = function() {
  return /** @type{!Array.<!proto.protocol.Peer>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.protocol.Peer, 1));
};


/** @param {!Array.<!proto.protocol.Peer>} value */
proto.protocol.Peers.prototype.setPeersList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.protocol.Peer=} opt_value
 * @param {number=} opt_index
 * @return {!proto.protocol.Peer}
 */
proto.protocol.Peers.prototype.addPeers = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.protocol.Peer, opt_index);
};


proto.protocol.Peers.prototype.clearPeersList = function() {
  this.setPeersList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.protocol.GetLedgers = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.protocol.GetLedgers, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.protocol.GetLedgers.displayName = 'proto.protocol.GetLedgers';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.protocol.GetLedgers.prototype.toObject = function(opt_includeInstance) {
  return proto.protocol.GetLedgers.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.protocol.GetLedgers} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.GetLedgers.toObject = function(includeInstance, msg) {
  var f, obj = {
    begin: jspb.Message.getFieldWithDefault(msg, 1, 0),
    end: jspb.Message.getFieldWithDefault(msg, 2, 0),
    timestamp: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.protocol.GetLedgers}
 */
proto.protocol.GetLedgers.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.protocol.GetLedgers;
  return proto.protocol.GetLedgers.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.protocol.GetLedgers} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.protocol.GetLedgers}
 */
proto.protocol.GetLedgers.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setBegin(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setEnd(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTimestamp(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.protocol.GetLedgers.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.protocol.GetLedgers.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.protocol.GetLedgers} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.GetLedgers.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBegin();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = message.getEnd();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getTimestamp();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
};


/**
 * optional int64 begin = 1;
 * @return {number}
 */
proto.protocol.GetLedgers.prototype.getBegin = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.protocol.GetLedgers.prototype.setBegin = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional int64 end = 2;
 * @return {number}
 */
proto.protocol.GetLedgers.prototype.getEnd = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.protocol.GetLedgers.prototype.setEnd = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional int64 timestamp = 3;
 * @return {number}
 */
proto.protocol.GetLedgers.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.protocol.GetLedgers.prototype.setTimestamp = function(value) {
  jspb.Message.setProto3IntField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.protocol.Ledgers = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.protocol.Ledgers.repeatedFields_, null);
};
goog.inherits(proto.protocol.Ledgers, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.protocol.Ledgers.displayName = 'proto.protocol.Ledgers';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.protocol.Ledgers.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.protocol.Ledgers.prototype.toObject = function(opt_includeInstance) {
  return proto.protocol.Ledgers.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.protocol.Ledgers} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.Ledgers.toObject = function(includeInstance, msg) {
  var f, obj = {
    valuesList: jspb.Message.toObjectList(msg.getValuesList(),
    chain_pb.ConsensusValue.toObject, includeInstance),
    syncCode: jspb.Message.getFieldWithDefault(msg, 2, 0),
    maxSeq: jspb.Message.getFieldWithDefault(msg, 3, 0),
    proof: msg.getProof_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.protocol.Ledgers}
 */
proto.protocol.Ledgers.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.protocol.Ledgers;
  return proto.protocol.Ledgers.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.protocol.Ledgers} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.protocol.Ledgers}
 */
proto.protocol.Ledgers.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new chain_pb.ConsensusValue;
      reader.readMessage(value,chain_pb.ConsensusValue.deserializeBinaryFromReader);
      msg.addValues(value);
      break;
    case 2:
      var value = /** @type {!proto.protocol.Ledgers.SyncCode} */ (reader.readEnum());
      msg.setSyncCode(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxSeq(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setProof(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.protocol.Ledgers.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.protocol.Ledgers.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.protocol.Ledgers} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.Ledgers.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValuesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      chain_pb.ConsensusValue.serializeBinaryToWriter
    );
  }
  f = message.getSyncCode();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = message.getMaxSeq();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getProof_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.protocol.Ledgers.SyncCode = {
  OK: 0,
  OUT_OF_SYNC: 1,
  OUT_OF_LEDGERS: 2,
  BUSY: 3,
  REFUSE: 4,
  INTERNAL: 5
};

/**
 * repeated ConsensusValue values = 1;
 * @return {!Array.<!proto.protocol.ConsensusValue>}
 */
proto.protocol.Ledgers.prototype.getValuesList = function() {
  return /** @type{!Array.<!proto.protocol.ConsensusValue>} */ (
    jspb.Message.getRepeatedWrapperField(this, chain_pb.ConsensusValue, 1));
};


/** @param {!Array.<!proto.protocol.ConsensusValue>} value */
proto.protocol.Ledgers.prototype.setValuesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.protocol.ConsensusValue=} opt_value
 * @param {number=} opt_index
 * @return {!proto.protocol.ConsensusValue}
 */
proto.protocol.Ledgers.prototype.addValues = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.protocol.ConsensusValue, opt_index);
};


proto.protocol.Ledgers.prototype.clearValuesList = function() {
  this.setValuesList([]);
};


/**
 * optional SyncCode sync_code = 2;
 * @return {!proto.protocol.Ledgers.SyncCode}
 */
proto.protocol.Ledgers.prototype.getSyncCode = function() {
  return /** @type {!proto.protocol.Ledgers.SyncCode} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {!proto.protocol.Ledgers.SyncCode} value */
proto.protocol.Ledgers.prototype.setSyncCode = function(value) {
  jspb.Message.setProto3EnumField(this, 2, value);
};


/**
 * optional int64 max_seq = 3;
 * @return {number}
 */
proto.protocol.Ledgers.prototype.getMaxSeq = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.protocol.Ledgers.prototype.setMaxSeq = function(value) {
  jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional bytes proof = 4;
 * @return {!(string|Uint8Array)}
 */
proto.protocol.Ledgers.prototype.getProof = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes proof = 4;
 * This is a type-conversion wrapper around `getProof()`
 * @return {string}
 */
proto.protocol.Ledgers.prototype.getProof_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getProof()));
};


/**
 * optional bytes proof = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getProof()`
 * @return {!Uint8Array}
 */
proto.protocol.Ledgers.prototype.getProof_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getProof()));
};


/** @param {!(string|Uint8Array)} value */
proto.protocol.Ledgers.prototype.setProof = function(value) {
  jspb.Message.setProto3BytesField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.protocol.DontHave = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.protocol.DontHave, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.protocol.DontHave.displayName = 'proto.protocol.DontHave';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.protocol.DontHave.prototype.toObject = function(opt_includeInstance) {
  return proto.protocol.DontHave.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.protocol.DontHave} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.DontHave.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: jspb.Message.getFieldWithDefault(msg, 1, 0),
    hash: msg.getHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.protocol.DontHave}
 */
proto.protocol.DontHave.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.protocol.DontHave;
  return proto.protocol.DontHave.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.protocol.DontHave} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.protocol.DontHave}
 */
proto.protocol.DontHave.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setType(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.protocol.DontHave.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.protocol.DontHave.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.protocol.DontHave} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.DontHave.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getType();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = message.getHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional int64 type = 1;
 * @return {number}
 */
proto.protocol.DontHave.prototype.getType = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.protocol.DontHave.prototype.setType = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional bytes hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.protocol.DontHave.prototype.getHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes hash = 2;
 * This is a type-conversion wrapper around `getHash()`
 * @return {string}
 */
proto.protocol.DontHave.prototype.getHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHash()));
};


/**
 * optional bytes hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHash()`
 * @return {!Uint8Array}
 */
proto.protocol.DontHave.prototype.getHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.protocol.DontHave.prototype.setHash = function(value) {
  jspb.Message.setProto3BytesField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.protocol.LedgerUpgradeNotify = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.protocol.LedgerUpgradeNotify, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.protocol.LedgerUpgradeNotify.displayName = 'proto.protocol.LedgerUpgradeNotify';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.protocol.LedgerUpgradeNotify.prototype.toObject = function(opt_includeInstance) {
  return proto.protocol.LedgerUpgradeNotify.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.protocol.LedgerUpgradeNotify} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.LedgerUpgradeNotify.toObject = function(includeInstance, msg) {
  var f, obj = {
    nonce: jspb.Message.getFieldWithDefault(msg, 1, 0),
    upgrade: (f = msg.getUpgrade()) && common_pb.LedgerUpgrade.toObject(includeInstance, f),
    signature: (f = msg.getSignature()) && common_pb.Signature.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.protocol.LedgerUpgradeNotify}
 */
proto.protocol.LedgerUpgradeNotify.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.protocol.LedgerUpgradeNotify;
  return proto.protocol.LedgerUpgradeNotify.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.protocol.LedgerUpgradeNotify} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.protocol.LedgerUpgradeNotify}
 */
proto.protocol.LedgerUpgradeNotify.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setNonce(value);
      break;
    case 2:
      var value = new common_pb.LedgerUpgrade;
      reader.readMessage(value,common_pb.LedgerUpgrade.deserializeBinaryFromReader);
      msg.setUpgrade(value);
      break;
    case 3:
      var value = new common_pb.Signature;
      reader.readMessage(value,common_pb.Signature.deserializeBinaryFromReader);
      msg.setSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.protocol.LedgerUpgradeNotify.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.protocol.LedgerUpgradeNotify.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.protocol.LedgerUpgradeNotify} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.LedgerUpgradeNotify.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNonce();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = message.getUpgrade();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      common_pb.LedgerUpgrade.serializeBinaryToWriter
    );
  }
  f = message.getSignature();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      common_pb.Signature.serializeBinaryToWriter
    );
  }
};


/**
 * optional int64 nonce = 1;
 * @return {number}
 */
proto.protocol.LedgerUpgradeNotify.prototype.getNonce = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.protocol.LedgerUpgradeNotify.prototype.setNonce = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional LedgerUpgrade upgrade = 2;
 * @return {?proto.protocol.LedgerUpgrade}
 */
proto.protocol.LedgerUpgradeNotify.prototype.getUpgrade = function() {
  return /** @type{?proto.protocol.LedgerUpgrade} */ (
    jspb.Message.getWrapperField(this, common_pb.LedgerUpgrade, 2));
};


/** @param {?proto.protocol.LedgerUpgrade|undefined} value */
proto.protocol.LedgerUpgradeNotify.prototype.setUpgrade = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.protocol.LedgerUpgradeNotify.prototype.clearUpgrade = function() {
  this.setUpgrade(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.protocol.LedgerUpgradeNotify.prototype.hasUpgrade = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional Signature signature = 3;
 * @return {?proto.protocol.Signature}
 */
proto.protocol.LedgerUpgradeNotify.prototype.getSignature = function() {
  return /** @type{?proto.protocol.Signature} */ (
    jspb.Message.getWrapperField(this, common_pb.Signature, 3));
};


/** @param {?proto.protocol.Signature|undefined} value */
proto.protocol.LedgerUpgradeNotify.prototype.setSignature = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.protocol.LedgerUpgradeNotify.prototype.clearSignature = function() {
  this.setSignature(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.protocol.LedgerUpgradeNotify.prototype.hasSignature = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.protocol.EntryList = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.protocol.EntryList.repeatedFields_, null);
};
goog.inherits(proto.protocol.EntryList, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.protocol.EntryList.displayName = 'proto.protocol.EntryList';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.protocol.EntryList.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.protocol.EntryList.prototype.toObject = function(opt_includeInstance) {
  return proto.protocol.EntryList.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.protocol.EntryList} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.EntryList.toObject = function(includeInstance, msg) {
  var f, obj = {
    entryList: msg.getEntryList_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.protocol.EntryList}
 */
proto.protocol.EntryList.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.protocol.EntryList;
  return proto.protocol.EntryList.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.protocol.EntryList} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.protocol.EntryList}
 */
proto.protocol.EntryList.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addEntry(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.protocol.EntryList.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.protocol.EntryList.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.protocol.EntryList} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.EntryList.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEntryList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      1,
      f
    );
  }
};


/**
 * repeated bytes entry = 1;
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.protocol.EntryList.prototype.getEntryList = function() {
  return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getRepeatedField(this, 1));
};


/**
 * repeated bytes entry = 1;
 * This is a type-conversion wrapper around `getEntryList()`
 * @return {!Array.<string>}
 */
proto.protocol.EntryList.prototype.getEntryList_asB64 = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.bytesListAsB64(
      this.getEntryList()));
};


/**
 * repeated bytes entry = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getEntryList()`
 * @return {!Array.<!Uint8Array>}
 */
proto.protocol.EntryList.prototype.getEntryList_asU8 = function() {
  return /** @type {!Array.<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getEntryList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value */
proto.protocol.EntryList.prototype.setEntryList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 */
proto.protocol.EntryList.prototype.addEntry = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.protocol.EntryList.prototype.clearEntryList = function() {
  this.setEntryList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.protocol.ChainHello = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.protocol.ChainHello.repeatedFields_, null);
};
goog.inherits(proto.protocol.ChainHello, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.protocol.ChainHello.displayName = 'proto.protocol.ChainHello';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.protocol.ChainHello.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.protocol.ChainHello.prototype.toObject = function(opt_includeInstance) {
  return proto.protocol.ChainHello.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.protocol.ChainHello} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.ChainHello.toObject = function(includeInstance, msg) {
  var f, obj = {
    apiListList: jspb.Message.getRepeatedField(msg, 1),
    timestamp: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.protocol.ChainHello}
 */
proto.protocol.ChainHello.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.protocol.ChainHello;
  return proto.protocol.ChainHello.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.protocol.ChainHello} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.protocol.ChainHello}
 */
proto.protocol.ChainHello.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Array.<!proto.protocol.ChainMessageType>} */ (reader.readPackedEnum());
      msg.setApiListList(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTimestamp(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.protocol.ChainHello.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.protocol.ChainHello.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.protocol.ChainHello} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.ChainHello.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getApiListList();
  if (f.length > 0) {
    writer.writePackedEnum(
      1,
      f
    );
  }
  f = message.getTimestamp();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
};


/**
 * repeated ChainMessageType api_list = 1;
 * @return {!Array.<!proto.protocol.ChainMessageType>}
 */
proto.protocol.ChainHello.prototype.getApiListList = function() {
  return /** @type {!Array.<!proto.protocol.ChainMessageType>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array.<!proto.protocol.ChainMessageType>} value */
proto.protocol.ChainHello.prototype.setApiListList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!proto.protocol.ChainMessageType} value
 * @param {number=} opt_index
 */
proto.protocol.ChainHello.prototype.addApiList = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.protocol.ChainHello.prototype.clearApiListList = function() {
  this.setApiListList([]);
};


/**
 * optional int64 timestamp = 2;
 * @return {number}
 */
proto.protocol.ChainHello.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.protocol.ChainHello.prototype.setTimestamp = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.protocol.ChainStatus = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.protocol.ChainStatus, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.protocol.ChainStatus.displayName = 'proto.protocol.ChainStatus';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.protocol.ChainStatus.prototype.toObject = function(opt_includeInstance) {
  return proto.protocol.ChainStatus.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.protocol.ChainStatus} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.ChainStatus.toObject = function(includeInstance, msg) {
  var f, obj = {
    selfAddr: jspb.Message.getFieldWithDefault(msg, 1, ""),
    ledgerVersion: jspb.Message.getFieldWithDefault(msg, 2, 0),
    monitorVersion: jspb.Message.getFieldWithDefault(msg, 3, 0),
    phantomVersion: jspb.Message.getFieldWithDefault(msg, 4, ""),
    timestamp: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.protocol.ChainStatus}
 */
proto.protocol.ChainStatus.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.protocol.ChainStatus;
  return proto.protocol.ChainStatus.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.protocol.ChainStatus} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.protocol.ChainStatus}
 */
proto.protocol.ChainStatus.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSelfAddr(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setLedgerVersion(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMonitorVersion(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setPhantomVersion(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTimestamp(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.protocol.ChainStatus.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.protocol.ChainStatus.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.protocol.ChainStatus} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.ChainStatus.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSelfAddr();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getLedgerVersion();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getMonitorVersion();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getPhantomVersion();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getTimestamp();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
};


/**
 * optional string self_addr = 1;
 * @return {string}
 */
proto.protocol.ChainStatus.prototype.getSelfAddr = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.protocol.ChainStatus.prototype.setSelfAddr = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional int64 ledger_version = 2;
 * @return {number}
 */
proto.protocol.ChainStatus.prototype.getLedgerVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.protocol.ChainStatus.prototype.setLedgerVersion = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional int64 monitor_version = 3;
 * @return {number}
 */
proto.protocol.ChainStatus.prototype.getMonitorVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.protocol.ChainStatus.prototype.setMonitorVersion = function(value) {
  jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional string phantom_version = 4;
 * @return {string}
 */
proto.protocol.ChainStatus.prototype.getPhantomVersion = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/** @param {string} value */
proto.protocol.ChainStatus.prototype.setPhantomVersion = function(value) {
  jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional int64 timestamp = 5;
 * @return {number}
 */
proto.protocol.ChainStatus.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.protocol.ChainStatus.prototype.setTimestamp = function(value) {
  jspb.Message.setProto3IntField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.protocol.ChainPeerMessage = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.protocol.ChainPeerMessage.repeatedFields_, null);
};
goog.inherits(proto.protocol.ChainPeerMessage, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.protocol.ChainPeerMessage.displayName = 'proto.protocol.ChainPeerMessage';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.protocol.ChainPeerMessage.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.protocol.ChainPeerMessage.prototype.toObject = function(opt_includeInstance) {
  return proto.protocol.ChainPeerMessage.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.protocol.ChainPeerMessage} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.ChainPeerMessage.toObject = function(includeInstance, msg) {
  var f, obj = {
    srcPeerAddr: jspb.Message.getFieldWithDefault(msg, 1, ""),
    desPeerAddrsList: jspb.Message.getRepeatedField(msg, 2),
    data: msg.getData_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.protocol.ChainPeerMessage}
 */
proto.protocol.ChainPeerMessage.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.protocol.ChainPeerMessage;
  return proto.protocol.ChainPeerMessage.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.protocol.ChainPeerMessage} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.protocol.ChainPeerMessage}
 */
proto.protocol.ChainPeerMessage.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSrcPeerAddr(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.addDesPeerAddrs(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.protocol.ChainPeerMessage.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.protocol.ChainPeerMessage.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.protocol.ChainPeerMessage} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.ChainPeerMessage.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSrcPeerAddr();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getDesPeerAddrsList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      2,
      f
    );
  }
  f = message.getData_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional string src_peer_addr = 1;
 * @return {string}
 */
proto.protocol.ChainPeerMessage.prototype.getSrcPeerAddr = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.protocol.ChainPeerMessage.prototype.setSrcPeerAddr = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * repeated string des_peer_addrs = 2;
 * @return {!Array.<string>}
 */
proto.protocol.ChainPeerMessage.prototype.getDesPeerAddrsList = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.getRepeatedField(this, 2));
};


/** @param {!Array.<string>} value */
proto.protocol.ChainPeerMessage.prototype.setDesPeerAddrsList = function(value) {
  jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {!string} value
 * @param {number=} opt_index
 */
proto.protocol.ChainPeerMessage.prototype.addDesPeerAddrs = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


proto.protocol.ChainPeerMessage.prototype.clearDesPeerAddrsList = function() {
  this.setDesPeerAddrsList([]);
};


/**
 * optional bytes data = 3;
 * @return {!(string|Uint8Array)}
 */
proto.protocol.ChainPeerMessage.prototype.getData = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes data = 3;
 * This is a type-conversion wrapper around `getData()`
 * @return {string}
 */
proto.protocol.ChainPeerMessage.prototype.getData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getData()));
};


/**
 * optional bytes data = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getData()`
 * @return {!Uint8Array}
 */
proto.protocol.ChainPeerMessage.prototype.getData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getData()));
};


/** @param {!(string|Uint8Array)} value */
proto.protocol.ChainPeerMessage.prototype.setData = function(value) {
  jspb.Message.setProto3BytesField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.protocol.ChainSubscribeTx = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.protocol.ChainSubscribeTx.repeatedFields_, null);
};
goog.inherits(proto.protocol.ChainSubscribeTx, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.protocol.ChainSubscribeTx.displayName = 'proto.protocol.ChainSubscribeTx';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.protocol.ChainSubscribeTx.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.protocol.ChainSubscribeTx.prototype.toObject = function(opt_includeInstance) {
  return proto.protocol.ChainSubscribeTx.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.protocol.ChainSubscribeTx} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.ChainSubscribeTx.toObject = function(includeInstance, msg) {
  var f, obj = {
    addressList: jspb.Message.getRepeatedField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.protocol.ChainSubscribeTx}
 */
proto.protocol.ChainSubscribeTx.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.protocol.ChainSubscribeTx;
  return proto.protocol.ChainSubscribeTx.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.protocol.ChainSubscribeTx} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.protocol.ChainSubscribeTx}
 */
proto.protocol.ChainSubscribeTx.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.addAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.protocol.ChainSubscribeTx.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.protocol.ChainSubscribeTx.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.protocol.ChainSubscribeTx} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.ChainSubscribeTx.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddressList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      1,
      f
    );
  }
};


/**
 * repeated string address = 1;
 * @return {!Array.<string>}
 */
proto.protocol.ChainSubscribeTx.prototype.getAddressList = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array.<string>} value */
proto.protocol.ChainSubscribeTx.prototype.setAddressList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!string} value
 * @param {number=} opt_index
 */
proto.protocol.ChainSubscribeTx.prototype.addAddress = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.protocol.ChainSubscribeTx.prototype.clearAddressList = function() {
  this.setAddressList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.protocol.ChainResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.protocol.ChainResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.protocol.ChainResponse.displayName = 'proto.protocol.ChainResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.protocol.ChainResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.protocol.ChainResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.protocol.ChainResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.ChainResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    errorCode: jspb.Message.getFieldWithDefault(msg, 1, 0),
    errorDesc: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.protocol.ChainResponse}
 */
proto.protocol.ChainResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.protocol.ChainResponse;
  return proto.protocol.ChainResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.protocol.ChainResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.protocol.ChainResponse}
 */
proto.protocol.ChainResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setErrorCode(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setErrorDesc(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.protocol.ChainResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.protocol.ChainResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.protocol.ChainResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.ChainResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getErrorCode();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = message.getErrorDesc();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional int32 error_code = 1;
 * @return {number}
 */
proto.protocol.ChainResponse.prototype.getErrorCode = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.protocol.ChainResponse.prototype.setErrorCode = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string error_desc = 2;
 * @return {string}
 */
proto.protocol.ChainResponse.prototype.getErrorDesc = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.protocol.ChainResponse.prototype.setErrorDesc = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.protocol.ChainTxStatus = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.protocol.ChainTxStatus, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.protocol.ChainTxStatus.displayName = 'proto.protocol.ChainTxStatus';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.protocol.ChainTxStatus.prototype.toObject = function(opt_includeInstance) {
  return proto.protocol.ChainTxStatus.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.protocol.ChainTxStatus} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.ChainTxStatus.toObject = function(includeInstance, msg) {
  var f, obj = {
    status: jspb.Message.getFieldWithDefault(msg, 1, 0),
    txHash: jspb.Message.getFieldWithDefault(msg, 2, ""),
    sourceAddress: jspb.Message.getFieldWithDefault(msg, 3, ""),
    sourceAccountSeq: jspb.Message.getFieldWithDefault(msg, 4, 0),
    ledgerSeq: jspb.Message.getFieldWithDefault(msg, 5, 0),
    newAccountSeq: jspb.Message.getFieldWithDefault(msg, 6, 0),
    errorCode: jspb.Message.getFieldWithDefault(msg, 7, 0),
    errorDesc: jspb.Message.getFieldWithDefault(msg, 8, ""),
    timestamp: jspb.Message.getFieldWithDefault(msg, 9, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.protocol.ChainTxStatus}
 */
proto.protocol.ChainTxStatus.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.protocol.ChainTxStatus;
  return proto.protocol.ChainTxStatus.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.protocol.ChainTxStatus} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.protocol.ChainTxStatus}
 */
proto.protocol.ChainTxStatus.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.protocol.ChainTxStatus.TxStatus} */ (reader.readEnum());
      msg.setStatus(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setTxHash(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setSourceAddress(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setSourceAccountSeq(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setLedgerSeq(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setNewAccountSeq(value);
      break;
    case 7:
      var value = /** @type {!proto.protocol.ERRORCODE} */ (reader.readEnum());
      msg.setErrorCode(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.setErrorDesc(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTimestamp(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.protocol.ChainTxStatus.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.protocol.ChainTxStatus.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.protocol.ChainTxStatus} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.protocol.ChainTxStatus.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getStatus();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getTxHash();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getSourceAddress();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getSourceAccountSeq();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = message.getLedgerSeq();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getNewAccountSeq();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
  f = message.getErrorCode();
  if (f !== 0.0) {
    writer.writeEnum(
      7,
      f
    );
  }
  f = message.getErrorDesc();
  if (f.length > 0) {
    writer.writeString(
      8,
      f
    );
  }
  f = message.getTimestamp();
  if (f !== 0) {
    writer.writeInt64(
      9,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.protocol.ChainTxStatus.TxStatus = {
  UNDEFINED: 0,
  CONFIRMED: 1,
  PENDING: 2,
  COMPLETE: 3,
  FAILURE: 4
};

/**
 * optional TxStatus status = 1;
 * @return {!proto.protocol.ChainTxStatus.TxStatus}
 */
proto.protocol.ChainTxStatus.prototype.getStatus = function() {
  return /** @type {!proto.protocol.ChainTxStatus.TxStatus} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {!proto.protocol.ChainTxStatus.TxStatus} value */
proto.protocol.ChainTxStatus.prototype.setStatus = function(value) {
  jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional string tx_hash = 2;
 * @return {string}
 */
proto.protocol.ChainTxStatus.prototype.getTxHash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.protocol.ChainTxStatus.prototype.setTxHash = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string source_address = 3;
 * @return {string}
 */
proto.protocol.ChainTxStatus.prototype.getSourceAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.protocol.ChainTxStatus.prototype.setSourceAddress = function(value) {
  jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional int64 source_account_seq = 4;
 * @return {number}
 */
proto.protocol.ChainTxStatus.prototype.getSourceAccountSeq = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.protocol.ChainTxStatus.prototype.setSourceAccountSeq = function(value) {
  jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional int64 ledger_seq = 5;
 * @return {number}
 */
proto.protocol.ChainTxStatus.prototype.getLedgerSeq = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.protocol.ChainTxStatus.prototype.setLedgerSeq = function(value) {
  jspb.Message.setProto3IntField(this, 5, value);
};


/**
 * optional int64 new_account_seq = 6;
 * @return {number}
 */
proto.protocol.ChainTxStatus.prototype.getNewAccountSeq = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.protocol.ChainTxStatus.prototype.setNewAccountSeq = function(value) {
  jspb.Message.setProto3IntField(this, 6, value);
};


/**
 * optional ERRORCODE error_code = 7;
 * @return {!proto.protocol.ERRORCODE}
 */
proto.protocol.ChainTxStatus.prototype.getErrorCode = function() {
  return /** @type {!proto.protocol.ERRORCODE} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {!proto.protocol.ERRORCODE} value */
proto.protocol.ChainTxStatus.prototype.setErrorCode = function(value) {
  jspb.Message.setProto3EnumField(this, 7, value);
};


/**
 * optional string error_desc = 8;
 * @return {string}
 */
proto.protocol.ChainTxStatus.prototype.getErrorDesc = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/** @param {string} value */
proto.protocol.ChainTxStatus.prototype.setErrorDesc = function(value) {
  jspb.Message.setProto3StringField(this, 8, value);
};


/**
 * optional int64 timestamp = 9;
 * @return {number}
 */
proto.protocol.ChainTxStatus.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.protocol.ChainTxStatus.prototype.setTimestamp = function(value) {
  jspb.Message.setProto3IntField(this, 9, value);
};


/**
 * @enum {number}
 */
proto.protocol.OVERLAY_MESSAGE_TYPE = {
  OVERLAY_MSGTYPE_NONE: 0,
  OVERLAY_MSGTYPE_PING: 1,
  OVERLAY_MSGTYPE_HELLO: 2,
  OVERLAY_MSGTYPE_PEERS: 3,
  OVERLAY_MSGTYPE_TRANSACTION: 4,
  OVERLAY_MSGTYPE_LEDGERS: 5,
  OVERLAY_MSGTYPE_PBFT: 6,
  OVERLAY_MSGTYPE_LEDGER_UPGRADE_NOTIFY: 7
};

/**
 * @enum {number}
 */
proto.protocol.ChainMessageType = {
  CHAIN_TYPE_NONE: 0,
  CHAIN_HELLO: 10,
  CHAIN_TX_STATUS: 11,
  CHAIN_PEER_ONLINE: 12,
  CHAIN_PEER_OFFLINE: 13,
  CHAIN_PEER_MESSAGE: 14,
  CHAIN_SUBMITTRANSACTION: 15,
  CHAIN_LEDGER_HEADER: 16,
  CHAIN_SUBSCRIBE_TX: 17,
  CHAIN_TX_ENV_STORE: 18
};

goog.object.extend(exports, proto.protocol);
